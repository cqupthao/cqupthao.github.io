<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo博客安装和Matery主题优化配置</title>
      <link href="/posts/36738.html"/>
      <url>/posts/36738.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Hexo-的安装"><a href="#Hexo-的安装" class="headerlink" title="Hexo 的安装"></a>Hexo 的安装</h1><hr><p><a href="https://hexo.io/themes/">Hexo</a> 是一款基于 Node.js 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 GitHub 、Gitee 上，是搭建博客的首选框架。</p><hr><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><hr><p>Git 是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span> <span class="token parameter variable">-y</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><hr><p>Hexo 是基于 Node.js 编写的，所以需要安装一下 Node.js 和 npm 工具。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> nodejs <span class="token function">npm</span> <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完后，输入如下命令，检查是否安装成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>升级 npm 到最新版本，更换 npm 源为淘宝源。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> <span class="token function">npm</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="升级-Node-js-版本"><a href="#升级-Node-js-版本" class="headerlink" title="升级 Node.js 版本"></a>升级 Node.js 版本</h2><hr><ul><li>清除 npm 缓存</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> cache clean <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装 Node.js 版本管理工具 n</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> n <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看 Node.js 所有版本</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> view <span class="token function">node</span> versions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>升级 Node.js 版本</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 升级到指定的版本：n 版本号</span>n <span class="token number">16.0</span>.0<span class="token comment"># 升级到最新的稳定版本</span>n stable<span class="token comment"># 升级到最新版本，不推荐</span>n latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>node -v</code> 查看 Node.js 版本，如果版本号改变为想要的则升级成功。如果版本号没变，可以重启机器或者尝试以下方法：</p><ol><li>查看安装 Node.js 的位置</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> <span class="token function">node</span>  /usr/local/n/versions/node/16.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>进入该位置</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/n/versions/node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>编辑 <code>/etc/profile</code> ，将 Node.js 安装的路径，添加到文件末尾</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">NODE_HOME</span><span class="token operator">=</span>/usr/local/n/versions/node/16.0.0<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">$NODE_HOME</span>/bin:<span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>输入 wq 退出保存文件，再编译 <code>/etc/profile</code></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><hr><p>前面 Git 和 Node.js 安装好后，就可以正式进行安装 Hexo 。</p><ol><li>安装 Hexo</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>查看版本信息</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_1425592747878800930944621.png"></p><hr><h2 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init filename（文件名随意定义）<span class="token builtin class-name">cd</span> filename //进入这个文件夹<span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_1018077824263297184815366.jpg"></p><hr><ul><li>hexo init </li></ul><blockquote><p>说明：自动在文件夹（filename）中创建项目所需的文件</p></blockquote><ul><li>cd filename</li></ul><blockquote><p>说明：将操作位置转移到将要存放项目的文件夹目录</p></blockquote><ul><li>npm install </li></ul><blockquote><p>说明：安装依赖包</p></blockquote><p>新建完成后，指定文件夹目录下有：</p><hr><ul><li><code>_config.yml</code> ：站点的配置文件，需要备份。</li><li><code>themes</code> ：主题文件夹，需要备份。</li><li><code>source</code> ：博客文章的 .md 文件，需要备份。</li><li><code>scaffolds</code> ：文章的模板，需要备份。</li><li><code>package.json</code> ：安装包的名称，需要备份。</li><li><code>.gitignore</code> ：限定在 push 时哪些文件可以忽略，需要备份 .git ：主题和站点都有，标志这是一个 git 项目，不需要备份。</li><li><code>node_modules</code> ：是安装包的目录，在执行 npm install 的时候会重新生成，不需要备份。</li><li><code>public</code> ：是 hexo g 生成的静态网页，不需要备份。</li><li><code>deploy_git</code> ：同上，hexo g 也会生成，不需要备份。</li><li><code>db.json</code> ：文件，不需要备份。</li></ul><hr><hr><h2 id="启动-Hexo-服务"><a href="#启动-Hexo-服务" class="headerlink" title="启动 Hexo 服务"></a>启动 Hexo 服务</h2><hr><p>正确安装完成后便按照下面操作启动 Hexo 博客。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token comment"># 生成静态页面至 public 目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server <span class="token comment"># 开启预览访问端口（默认端口 4000 ，ctrl + c 关闭 server ）</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_1426494387056801777394283.png"></p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2022_1223_142923.png"></p><hr><p>打开浏览器输入对应的网址 <strong><a href="http://localhost:4000/">http://localhost:4000</a></strong> ，就可以看到生成的博客。</p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_1435241192715661277456756.png"></p><hr><h1 id="Hexo-部署到-GitHub"><a href="#Hexo-部署到-GitHub" class="headerlink" title="Hexo 部署到 GitHub"></a>Hexo 部署到 GitHub</h1><hr><hr><h2 id="在-GitHub-官网上创建个人仓库"><a href="#在-GitHub-官网上创建个人仓库" class="headerlink" title="在 GitHub 官网上创建个人仓库"></a>在 GitHub 官网上创建个人仓库</h2><hr><p>注册登录 <a href="https://github.com/">github官网</a>，点击右上角加号，点击 New repository ，新建仓库。</p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_1453048826363041159371369.png"></p><p>创建一个和用户名相同的仓库（即 <strong><a href="http://xxxx.github.io/">http://xxxx.github.io</a></strong> ，其中 <code>xxx</code> 是 github 的用户名），点击 Greate Repository 。</p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_1456556257341474192203571.png"></p><hr><h2 id="Git-初始化设置"><a href="#Git-初始化设置" class="headerlink" title="Git 初始化设置"></a>Git 初始化设置</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"yourname"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（yourname 是 github 用户名，youremail 是注册 github 的邮箱）</p><hr><h2 id="查看设置是否正确"><a href="#查看设置是否正确" class="headerlink" title="查看设置是否正确"></a>查看设置是否正确</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.email<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="生成-SSH-添加到-GitHub"><a href="#生成-SSH-添加到-GitHub" class="headerlink" title="生成 SSH 添加到 GitHub"></a>生成 SSH 添加到 GitHub</h2><hr><ul><li>创建 SSH ，默认回车</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200802_1139583858709568397913356.jpg"></p><ul><li>查看 SSH KEY</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0950183625923031218189922.jpg"></p><ul><li>复制 <code>id_rsa.pub</code> 里面的全部内容，在 GitHub 的 Setting 中，找到 SSH keys 的设置选项，点击 New SSH key，粘贴 <code>id_rsa.pub</code> 里面的全部内容。</li></ul><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_151404755358037895170688.png"></p><ul><li>查看是否连接成功</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token parameter variable">-T</span> git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0950365347089596365232504.jpg"></p><ul><li>打开站点配置文件 <code>_config.yml</code> ，修改添加以下内容</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>     <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span>    git@github.com<span class="token punctuation">:</span>yourgithubname/yourgithubname.github.io.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Hexo-部署到-GitHub-Pages"><a href="#Hexo-部署到-GitHub-Pages" class="headerlink" title="Hexo 部署到 GitHub Pages"></a>Hexo 部署到 GitHub Pages</h2><hr><ul><li>在部署到 GitHub 之前，安装如下扩展</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>部署到 GitHub</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完成后浏览器访问 <strong><a href="https://yourname.github.io/">https://yourname.github.io/</a></strong> （yourname 是 github 账号昵称）就可以看见和网址 <strong><a href="http://localhost:4000/">http://localhost:4000</a></strong> 一样的内容了。</p><hr><h1 id="Hexo-部署到-Gitee"><a href="#Hexo-部署到-Gitee" class="headerlink" title="Hexo 部署到 Gitee"></a>Hexo 部署到 Gitee</h1><hr><hr><h2 id="在-Gitee-官网上创建个人仓库"><a href="#在-Gitee-官网上创建个人仓库" class="headerlink" title="在 Gitee 官网上创建个人仓库"></a>在 Gitee 官网上创建个人仓库</h2><hr><p>打开<a href="https://gitee.com/">码云官网</a>，注册登陆，创建项目，点击右上角加号，新建仓库。</p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0802_2310411783559666911033042.png"></p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0802_23111427248098453871943831.png"></p><p>开启 Gitee Pages 服务。</p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0802_231221568468301236150357.png"></p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0937147843036425501178044.jpg"></p><p>点击启动，启动后，点击蓝色链接打开网址。</p><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0802_2314342325756989210353055.png"></p><hr><h2 id="初始化-Git-设置"><a href="#初始化-Git-设置" class="headerlink" title="初始化 Git 设置"></a>初始化 Git 设置</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"这里输入你的 gitee 注册名"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"这里输你的 gitee 邮箱"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="查看设置是否正确-1"><a href="#查看设置是否正确-1" class="headerlink" title="查看设置是否正确"></a>查看设置是否正确</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.email<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="生成-SSH-添加到-Gitee"><a href="#生成-SSH-添加到-Gitee" class="headerlink" title="生成 SSH 添加到 Gitee"></a>生成 SSH 添加到 Gitee</h2><hr><ul><li>创建 SSH ，默认回车</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200802_1139583858709568397913356.jpg"></p><ul><li>查看 SSH KEY</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0950183625923031218189922.jpg"></p><ul><li>复制 <code>id_rsa.pub</code> 里面的全部内容，在 gitee 的管理中，找到添加公钥的设置选项，点击 New SSH key ，粘贴 <code>id_rsa.pub</code> 里面的全部内容。</li></ul><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0802_2316484808107369418949929.png"></p><ul><li>查看是否连接成功</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token parameter variable">-T</span> git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0950365347089596365232504.jpg"></p><hr><h2 id="配置-config-yml-文件"><a href="#配置-config-yml-文件" class="headerlink" title="配置 _config.yml 文件"></a>配置 <code>_config.yml</code> 文件</h2><hr><p>（点击复制克隆/下载里面的 https 的内容）<br>修改添加 <code>_config.yml</code> 以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">url</span><span class="token punctuation">:</span> Gitee Pages 服务网站地址： https<span class="token punctuation">:</span>//空间名.gitee.io/仓库名<span class="token key atrule">root</span><span class="token punctuation">:</span> /仓库名/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> git      <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//gitee.com/空间名/仓库名      <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0808_2152243527362378310111202.png"></p><hr><h2 id="Hexo-部署到-Gitee-Pages"><a href="#Hexo-部署到-Gitee-Pages" class="headerlink" title="Hexo 部署到 Gitee Pages"></a>Hexo 部署到 Gitee Pages</h2><hr><ul><li>在部署到 Gitee 之前，安装如下扩展</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>部署到 Gitee</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完成后浏览器访问 <strong><a href="https://yourname.gitee.io/">https://yourname.gitee.io/</a></strong> （yourname 是 gitee 账号昵称）就可以看见和网址 <strong><a href="http://localhost:4000/">http://localhost:4000</a></strong> 一样的内容了。</p><hr><p>更多基础配置可以参考<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a>的配置说明。</p><hr><h1 id="Matery-主题安装及优化"><a href="#Matery-主题安装及优化" class="headerlink" title="Matery 主题安装及优化"></a>Matery 主题安装及优化</h1><hr><ul><li>Matery 主题安装参考 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">Matery 官网教程</a></li><li>Matery 优化参考 <a href="https://blog.17lai.site/posts/40300608/">基于 Hexo 的 matery 主题搭建博客并深度优化一站式完全教程</a></li></ul><hr><h1 id="Hexo-插件安装"><a href="#Hexo-插件安装" class="headerlink" title="Hexo 插件安装"></a>Hexo 插件安装</h1><hr><hr><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><hr><p>从 Hexo5.0 版本开始自带了 prismjs 代码语法高亮的支持，如果博客安装过 <code>hexo-prism-plugin</code> 的插件，须执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>修改 Hexo 根目录下 <code>_config.yml</code> 文件中 highlight.enable 的值为 false ，并将 prismjs.enable 的值设置为 true ，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主题中默认的 prismjs 主题是 Tomorrow Night ，如果想定制自己的主题，可前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a>  定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 <code>css</code> 主题文件取名为 <code>prism.css</code>，替换掉 Matery 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件。</p><hr><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><hr><p>使用 <code>hexo-generator-search</code> 的 Hexo 插件来实现内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="中文链接转拼音"><a href="#中文链接转拼音" class="headerlink" title="中文链接转拼音"></a>中文链接转拼音</h2><hr><p>使用 <code>hexo-permalink-pinyin</code> 的 Hexo 插件使在生成文章时生成中文拼音的永久链接，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以生成拼音链接。</p><hr><h2 id="文章生成永久链接"><a href="#文章生成永久链接" class="headerlink" title="文章生成永久链接"></a>文章生成永久链接</h2><hr><p>使用 <code>hexo-abbrlink</code> 的 Hexo 插件来实现文章生成永久链接，安装命令如下： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">abbrlink</span><span class="token punctuation">:</span>     <span class="token key atrule">alg</span><span class="token punctuation">:</span> crc16 <span class="token comment">#算法：</span>    <span class="token key atrule">rep</span><span class="token punctuation">:</span> hex <span class="token comment">#输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将 <code>_config.yml</code> 文件中的 permalink 的值修改为如下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink</span><span class="token punctuation">:</span> posts/<span class="token punctuation">:</span>abbrlink.html  <span class="token comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以生成永久链接。生成完后，原 md 文件的 Front-matter 内会增加 abbrlink 字段，值为生成的 ID 。</p><hr><h2 id="外链跳转插件"><a href="#外链跳转插件" class="headerlink" title="外链跳转插件"></a>外链跳转插件</h2><hr><p>使用 <code>hexo-external-link</code> 的 Hexo 插件来实现外链跳转，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-external-link <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">hexo_external_link</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">enable_base64_encode</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">url_param_name</span><span class="token punctuation">:</span> <span class="token string">'u'</span>  <span class="token key atrule">html_file_name</span><span class="token punctuation">:</span> <span class="token string">'go.html'</span>  <span class="token key atrule">target_blank</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">link_rel</span><span class="token punctuation">:</span> <span class="token string">'external nofollow noopener noreferrer'</span>  <span class="token key atrule">domain</span><span class="token punctuation">:</span> <span class="token string">'your_domain'</span> <span class="token comment"># 如果开启了防盗链，填写你的域名</span>  <span class="token key atrule">safety_chain</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现外链跳转。</p><hr><h2 id="文章字数统计插件"><a href="#文章字数统计插件" class="headerlink" title="文章字数统计插件"></a>文章字数统计插件</h2><hr><p>使用 <code>hexo-wordcount</code> 的 Hexo 插件来实现在文章中统计显示文章字数、阅读时长信息，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-wordcount <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Matery 主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true </span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现文章字数统计。</p><hr><h2 id="添加-emoji-表情支持"><a href="#添加-emoji-表情支持" class="headerlink" title="添加 emoji 表情支持"></a>添加 emoji 表情支持</h2><hr><p>使用 <code>hexo-filter-github-emojis</code> 的 Hexo 插件来支持 emoji 表情的生成，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中用 emoji 语法写表情。</p><hr><h2 id="添加-RSS-订阅支持"><a href="#添加-RSS-订阅支持" class="headerlink" title="添加 RSS 订阅支持"></a>添加 RSS 订阅支持</h2><hr><p>使用 <code>hexo-generator-feed</code> 的 Hexo 插件来做 RSS，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，在 <code>public</code> 文件夹中看到 <code>atom.xml</code> 文件，说明已安装成功。</p><hr><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><hr><p>使用 <code>hexo-lazyload-image</code> 的 Hexo 插件来实现图片懒加载，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-lazyload-image <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">lazyload</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>   <span class="token key atrule">onlypost</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token comment"># 是否只对文章的图片做懒加载</span>  <span class="token key atrule">loadingImg</span><span class="token punctuation">:</span> <span class="token comment"># eg ./images/loading.gif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，一般情况下懒加载会和 gallery 插件会发生冲突，结果可能就是点开图片，左翻右翻都是 loading image 。解决方案是：<br>修改 <code>/themes/matery/source/js</code> 中的 <code>matery.js</code> 文件在第 108 行加上：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'img[data-original]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">,</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"data-original"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>做完这步之后，还有点小 Bug ，首页的 logo 点击会直接打开 logo 图，而不是跳到首页。伪解决方案：打开  <code>/themes/matery/layout/_partial/header.ejs</code> 文件，在 img 和 span 的两个头加个 div ：</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;div class="brand-logo"&gt;    &lt;a href="&lt;%- url_for() %&gt;" class="waves-effect waves-light"&gt;        &lt;div&gt;            &lt;% if (theme.logo !== undefined &amp;&amp; theme.logo.length &gt; 0) { %&gt;            &lt;img src="&lt;%= theme.logo %&gt;" class="logo-img" alt="LOGO"&gt;            &lt;% } %&gt;            &lt;span class="logo-span"&gt;&lt;%- config.title %&gt;&lt;/span&gt;        &lt;/div&gt;    &lt;/a&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现图片懒加载。</p><hr><h2 id="折叠功能"><a href="#折叠功能" class="headerlink" title="折叠功能"></a>折叠功能</h2><hr><p>使用 <code>hexo-sliding-spoiler</code> 的 Hexo 插件来实现折叠功能，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-sliding-spoiler <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">plugin</span><span class="token punctuation">:</span><span class="token punctuation">-</span> hexo<span class="token punctuation">-</span>sliding<span class="token punctuation">-</span>spoiler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现折叠功能。</p><hr><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><hr><p>使用 <code>hexo-neat</code> 的 Hexo 插件来实现代码压缩，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-neat <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#hexo-neat 优化提速插件（去掉 HTML、css、js 的 blank字符）</span><span class="token key atrule">neat_enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">neat_html</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">'**/*.md'</span><span class="token key atrule">neat_css</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">'**/*.min.css'</span><span class="token key atrule">neat_js</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">mangle</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">output</span><span class="token punctuation">:</span>  <span class="token key atrule">compress</span><span class="token punctuation">:</span>  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">'**/*.min.js'</span>    <span class="token punctuation">-</span> <span class="token string">'**/**/instantpage.js'</span>    <span class="token punctuation">-</span> <span class="token string">'**/matery.js'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现代码压缩。</p><hr><p>更多的 Hexo 插件安装参考 <a href="https://hexo.io/plugins">Hexo 官网</a></p><hr><h1 id="Hexo-添加-Valine-评论系统"><a href="#Hexo-添加-Valine-评论系统" class="headerlink" title="Hexo 添加 Valine 评论系统"></a>Hexo 添加 Valine 评论系统</h1><hr><ul><li>在 <a href="https://console.leancloud.cn/">LeanCloud 官网</a>注册登录</li><li>创建一个应用，然后进入应用，点击设置，找到应用凭证</li><li>复制 AppID 和 AppKey 到 Matery 主题的 <code>config.yml</code> 配置文件中的对应位置</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.</span><span class="token key atrule">valine</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">appId</span><span class="token punctuation">:</span>  <span class="token comment"># 必填</span>  <span class="token key atrule">appKey</span><span class="token punctuation">:</span> <span class="token comment"># 必填</span>  <span class="token key atrule">serverURLs</span><span class="token punctuation">:</span>  <span class="token comment">#必填 https://你的api</span>  <span class="token key atrule">notify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">verify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">visitor</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">avatar</span><span class="token punctuation">:</span> <span class="token string">'mm'</span> <span class="token comment"># Gravatar style : mm/identicon/monsterid/wavatar/retro/hide</span>  <span class="token key atrule">pageSize</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">placeholder</span><span class="token punctuation">:</span> <span class="token string">'just go go'</span> <span class="token comment"># Comment Box placeholder</span>  <span class="token key atrule">background</span><span class="token punctuation">:</span> /medias/comment_bg.png  <span class="token key atrule">coolpushkey</span><span class="token punctuation">:</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>升级 valine 版本</li></ul><p>进入 <a href="https://unpkg.com/valine/dist/">valine 官网</a>， 选择 valine 版本后点击 <code>Valine.min.js</code> ，点击 View Raw 后复制 全部内容，粘贴替换 Matery 主题下的 <code>/source/libs/valine/Valine.min.js</code> 文件全部内容。</p><ul><li>增加 Valine 配置</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">valine</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">appId</span><span class="token punctuation">:</span> iTxfqh5e9IaRfiiVOTbIWoKa<span class="token punctuation">-</span>XXXXXX  <span class="token key atrule">appKey</span><span class="token punctuation">:</span> C5s5xGFErD1EtXXXXXXXX  <span class="token key atrule">verify</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 是否启用防垃圾验证</span>  <span class="token key atrule">notify</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 是否开启邮件提醒(https://valine.js.org/notify.html)</span>  <span class="token key atrule">visitor</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">avatar</span><span class="token punctuation">:</span> monsterid  <span class="token comment"># 头像样式(https://valine.js.org/avatar.html) </span>  <span class="token key atrule">pageSize</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">placeholder</span><span class="token punctuation">:</span> <span class="token string">'ヾﾉ≧∀≦)o来啊，快活啊!'</span> <span class="token comment"># Comment Box placeholder</span>  <span class="token key atrule">background</span><span class="token punctuation">:</span> /medias/comment_bg.png <span class="token comment">#背景图</span>  <span class="token key atrule">count</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">enableQQ</span><span class="token punctuation">:</span> <span class="token number">2733443175</span>  <span class="token key atrule">recordIP</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">requiredFields</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> nick    <span class="token punctuation">-</span> mail  <span class="token key atrule">guest_info</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> nick    <span class="token punctuation">-</span> mail    <span class="token punctuation">-</span> link  <span class="token key atrule">master</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> 123abc508165c8eba9a77f872xxxx046  <span class="token comment"># md5加密后的博主邮箱</span>  <span class="token key atrule">metaPlaceholder</span><span class="token punctuation">:</span>  <span class="token comment"># 输入框的背景文字</span>    <span class="token key atrule">nick</span><span class="token punctuation">:</span> 昵称/QQ号(必填)    <span class="token key atrule">mail</span><span class="token punctuation">:</span> 邮箱(必填)    <span class="token key atrule">link</span><span class="token punctuation">:</span> 网址(https<span class="token punctuation">:</span>//)  <span class="token key atrule">lang</span><span class="token punctuation">:</span> zh<span class="token punctuation">-</span>CN  <span class="token key atrule">tagMeta</span><span class="token punctuation">:</span> <span class="token comment"># The String Array of Words to show Flag.[Just Only xCss Style mode]</span>    <span class="token punctuation">-</span> 博主    <span class="token punctuation">-</span> 小伙伴    <span class="token punctuation">-</span> 访客  <span class="token key atrule">friends</span><span class="token punctuation">:</span> <span class="token comment"># The MD5 String Array of friends Email to show friends Flag.[Just Only xCss Style modde]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>更多内容访问 <a href="https://blog.17lai.site/posts/9b056c86/">基于Hexo的matery主题搭建博客个性定制篇5 </a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Matery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Hexo </tag>
            
            <tag> Gitee </tag>
            
            <tag> Matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用指南</title>
      <link href="/posts/19324.html"/>
      <url>/posts/19324.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Markdown概述"><a href="#Markdown概述" class="headerlink" title="Markdown概述"></a>Markdown概述</h2><hr><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a><strong>宗旨</strong></h3><p><strong>Markdown</strong> 的目标是实现「易读易写」。</p><p>一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。</p><h3 id="兼容HTML"><a href="#兼容HTML" class="headerlink" title="兼容HTML"></a><strong>兼容HTML</strong></h3><p><strong>Markdown</strong> 语法的目标是：成为一种适用于网络的书写语言。</p><p>Markdown 的构想不是要使得 HTML 文档更容易书写。Markdown 的设计理念是，能让文档更容易读、写和随意改。</p><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><hr><p>Markdown 标题有两种格式：</p><ol><li>使用 <strong>=</strong> 和 <strong>-</strong> 标记一级和二级标题。</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token title important">我展示的是一级标题<span class="token punctuation">=================</span></span><span class="token title important">我展示的是二级标题<span class="token punctuation">-----------------</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> 一级标题</span><span class="token title important"><span class="token punctuation">##</span> 二级标题</span><span class="token title important"><span class="token punctuation">###</span> 三级标题</span><span class="token title important"><span class="token punctuation">####</span> 四级标题</span><span class="token title important"><span class="token punctuation">#####</span> 五级标题</span><span class="token title important"><span class="token punctuation">######</span> 六级标题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="段落-文本换行"><a href="#段落-文本换行" class="headerlink" title="段落/文本换行"></a>段落/文本换行</h2><hr><p>Markdown 段落没有特殊的格式,直接编写文字, 段落换行是使用两个以上的空格加上回车/使用一个空行重新开始一个新的段落/使用 HTML 标签 <code>&lt;br&gt;</code> 。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> 段落 (两个空格+回车)  <span class="token list punctuation">2.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span> 段落 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>br</span><span class="token punctuation">&gt;</span></span>（使用 HTML 语言换行标签）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="文本添加缩进"><a href="#文本添加缩进" class="headerlink" title="文本添加缩进"></a>文本添加缩进</h2><hr><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">#使用 HTML 标签 &lt;style&gt; 实现&lt;p style="text-indent:1em"&gt;你好呀&lt;/p&gt;&lt;p style="text-indent:2em"&gt;你好呀&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p style="text-indent:1em">你好呀</p><p style="text-indent:2em">你好呀</p><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><hr><p>Markdown 可以使用以下几种字体：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span><span class="token content">斜体文本</span><span class="token punctuation">*</span></span><span class="token bold"><span class="token punctuation">**</span><span class="token content">粗体文本</span><span class="token punctuation">**</span></span><span class="token bold"><span class="token punctuation">**</span><span class="token content"><span class="token italic"><span class="token punctuation">*</span><span class="token content">粗斜体文本</span><span class="token punctuation">*</span></span></span><span class="token punctuation">**</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><hr><p>Markdown 使用连续两个单号包括高亮的部分实现内容的高亮。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">==高亮内容==<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><p>在一行中用三个以上的 <strong>星号</strong>、<strong>减号</strong>、<strong>底线</strong> 来建立一个分隔线，行内不能有其他东西或在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">-</span> ***<span class="token hr punctuation">- ---</span><span class="token list punctuation">-</span> ···<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><hr><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线即可。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">~~delete<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><hr><p>下划线可以通过 <strong>HTML</strong> 的标签来实现。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;u&gt;带下划线文本&lt;/u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><hr><p>使用 <strong>HTML</strong> 的注释方式。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!-- 注释 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><hr><p>脚注是对文本的补充说明，Markdown 脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">创建脚注格式 [^1] [^1] : 菜鸟教程 -- 学的不仅是技术，更是梦想!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h2><hr><p>使用 <strong>HTML</strong> 可以将文本居中。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;center&gt;居中的内容&lt;/center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h2><hr><p>Markdown 支持有序列表和无序列表。</p><ul><li>有序列表</li></ul><p>有序列表使用数字并加上 <strong>.</strong> 号来表示。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> 第一项<span class="token list punctuation">2.</span> 第二项<span class="token list punctuation">3.</span> 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>无序列表</li></ul><p>无序列表使用 <strong>星号</strong> （ <code>*</code> ）、<strong>加号</strong> （ <code>+</code> ）或是 <strong>减号</strong> （ <code>-</code> ）作为列表标记。</p> <pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">*</span> 第一项<span class="token list punctuation">*</span> 第二项<span class="token list punctuation">*</span> 第三项------ 分割线 ------<span class="token list punctuation">-</span> 第一项<span class="token list punctuation">-</span> 第二项<span class="token list punctuation">-</span> 第三项------ 分割线 ------<span class="token list punctuation">+</span> 第一项<span class="token list punctuation">+</span> 第二项<span class="token list punctuation">+</span> 第三项  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><hr><ol><li>区块引用</li></ol><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟 <strong>一个空格符号</strong> 。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token blockquote punctuation">&gt;</span> 区块引用<span class="token blockquote punctuation">&gt;</span> 菜鸟教程<span class="token blockquote punctuation">&gt;</span> 学的不仅是技术更是梦想<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>区块使用列表</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token blockquote punctuation">&gt;</span> 区块中使用列表<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">1.</span> 第一项<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">2.</span> 第二项<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">+</span> 第一项<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">+</span> 第二项<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">+</span> 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>列表中使用区块</li></ol><p>如果要在列表项目内放进区块，那么就需要在 <strong>&gt;</strong> 前添加四个空格的缩进。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">*</span> 第一项  &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想<span class="token list punctuation">*</span> 第二项     &gt;欢迎光临<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h2><hr><ol><li>单行代码</li></ol><p>如果是单行代码或段落上的一个函数或片段的代码可以用 <strong>反引号对</strong> 把它括起来。</p><p><code>fmt.Println("Hello Word!)</code></p><ol start="2"><li>代码区块</li></ol><p>代码区块使用 <strong>三个反引号对</strong> 包裹一段代码，并指定一种语言（也可以不指定）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h2><hr><ol><li>上标使用双 <strong>^</strong> 括住内容</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">x^2^<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>下标使用双 <strong>~</strong> 括住内容</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">H2<span class="token strike"><span class="token punctuation">~</span><span class="token content">0</span><span class="token punctuation">~</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Markdown超链接"><a href="#Markdown超链接" class="headerlink" title="Markdown超链接"></a>Markdown超链接</h2><hr><ul><li>一个方括号 <strong>[]</strong> ，里面放上链接的替代文字</li><li>接着一个普通括号 <strong>()</strong> ，里面放上网址</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 <span class="token url">[<span class="token content">Google</span>][<span class="token variable">1</span>]</span>这个链接用 baidu 作为网址变量 <span class="token url">[<span class="token content">百度</span>][<span class="token variable">baidu</span>]</span>然后在文档的结尾为变量赋值（网址）[1]:http://www.google.com/[baidu]:http://www.baidu.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><hr><ul><li><p>开头一个 感叹号 <strong>!</strong> </p></li><li><p>接着一个 方括号 <strong>[]</strong> ，里面放上图片的替代文字</p></li><li><p>接着一个 普通括号 <strong>()</strong> ，里面放上图片的网址，最后还可以用 <strong>引号</strong> 包住并加上选择性的 <strong>title</strong> 属性的文字</p></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token url"><span class="token operator">!</span>[<span class="token content">图片</span>](<span class="token url">http://www.baidu.com/img/logo.png</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20221210_145354.jpg" alt="图片"></p><hr><h2 id="设置图片"><a href="#设置图片" class="headerlink" title="设置图片"></a>设置图片</h2><hr><p>通过 center 居中，把 center 换成 left 和 right 可以实现居左或者居右，width 和 height 调控高度和宽度。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;div align=center&gt;&lt;img src="http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg" width="251" height="350"&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><div align="center"><img src="http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg" width="251" height="350"></div><hr><hr><h2 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h2><hr><p>插入视频实现依赖于 <strong>HTML</strong> 。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;video controls="" autoplay="" name="media"&gt;    &lt;source src="https://www.w3school.com.cn/example/html5/mov_bbb.mp4" type="video/mp4"&gt;&lt;/video&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p><video controls="" autoplay="" name="media">    <source src="https://www.w3school.com.cn/example/html5/mov_bbb.mp4" type="video/mp4"><br></video></p><hr><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;iframe    width=100%    height=120px    src='//player.bilibili.com/player.html?aid=455564468&amp;bvid=BV1H541147nA&amp;cid=187808769&amp;page=1'    frameborder="0"    allowfullscreen&gt;&lt;/iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><iframe width="100%" height="120px" src="//player.bilibili.com/player.html?aid=455564468&amp;bvid=BV1H541147nA&amp;cid=187808769&amp;page=1" frameborder="0" allowfullscreen=""></iframe><hr><ul><li><p>src 里面填视频原 URL</p></li><li><p>width 是视频宽度（可以填百分比）</p></li><li><p>height 是视频高度（可以填百分比）</p></li></ul><hr><h2 id="插入音乐"><a href="#插入音乐" class="headerlink" title="插入音乐"></a>插入音乐</h2><hr><p>插入音乐实现依赖于 <strong>HTML</strong> 。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;div align=center&gt;&lt;iframe frameborder="no" marginwidth="0" marginheight="0" width=300 height=90 src="https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><div align="center"><iframe frameborder="no" marginwidth="0" marginheight="0" width="300" height="90" src="https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66"></iframe></div><ul><li><p>div 用于控制格式，若无则默认为居左</p></li><li><p>frameborder 用于规定是否显示框架周围的边框，1 为是，0 为否</p></li><li><p>marginwidth 及 marginheight 表示距离边缘的像素大小</p></li><li><p>width 及 height 表示播放条的长度和宽度 src 为播放链接，可以在如网易云音乐的生成外链播放器获取该链接，同时也获得以下代码，并可以自行更改；也可将音频链接改为视频链接，从而播放视频</p></li></ul><hr><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><hr><p>输入 <code>|</code> 表头1 <code>|</code> 表头2 <code>|</code> 并回车,即可创建一个包含 2 列表。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token table"><span class="token table-header-row"><span class="token punctuation">|</span><span class="token table-header important"> 左对齐 </span><span class="token punctuation">|</span><span class="token table-header important"> 右对齐 </span><span class="token punctuation">|</span><span class="token table-header important"> 中对齐 </span><span class="token punctuation">|</span></span><span class="token table-line"><span class="token punctuation">|</span> <span class="token punctuation">:----</span> <span class="token punctuation">|</span> <span class="token punctuation">----:</span> <span class="token punctuation">|</span> <span class="token punctuation">:---:</span> <span class="token punctuation">|</span></span><span class="token table-data-rows"><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行。</p></li><li><p>列与列之间用管道符号 <code>|</code> 隔开，如果不使用对齐标记，内容默认左对齐，表头居中对齐</p></li></ul><hr><blockquote><p>-: 设置内容和标题栏居右对齐</p></blockquote><blockquote><p>:- 设置内容和标题栏居左对齐</p></blockquote><blockquote><p>:-: 设置内容和标题栏居中对齐</p></blockquote><hr><ul><li>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界</li><li>为了使 Markdown 更清晰，<code>|</code> 和 <code>-</code> 两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code> 外不需要）</li></ul><hr><h2 id="Markdown高级技巧"><a href="#Markdown高级技巧" class="headerlink" title="Markdown高级技巧"></a>Markdown高级技巧</h2><hr><h3 id="1-支持-HTML-元素"><a href="#1-支持-HTML-元素" class="headerlink" title="1. 支持 HTML 元素"></a>1. 支持 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><h3 id="2-转义"><a href="#2-转义" class="headerlink" title="2. 转义"></a>2. 转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符。</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号:</p><hr><ul><li>  <strong>\ 反斜线</strong></li><li>  <strong>` 反引号</strong></li><li>  <strong>星号 [*]</strong></li><li>  <strong>下划线</strong></li><li>  <strong>{} 花括号</strong></li><li>  <strong>[] 方括号</strong></li><li>  <strong>() 小括号</strong></li><li>  <strong># 井字号</strong></li><li>  <strong>+ 加号</strong></li><li>  <strong>- 减号</strong></li><li>  <strong>. 英文句点</strong></li><li>  <strong>! 感叹号</strong></li></ul><hr><hr><h2 id="文字颜色、大小、字体背景色"><a href="#文字颜色、大小、字体背景色" class="headerlink" title="文字颜色、大小、字体背景色"></a>文字颜色、大小、字体背景色</h2><hr><h3 id="1-字体大小"><a href="#1-字体大小" class="headerlink" title="1. 字体大小"></a>1. 字体大小</h3><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">size为1：&lt;font size="1"&gt;size为1&lt;/font&gt;                                     size为3：&lt;font size="3"&gt;size为3&lt;/font&gt;size为4：&lt;font size="4"&gt;size为4&lt;/font&gt;size为6：&lt;font size="6"&gt;size为6&lt;/font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>size为1：<font size="1">size为1</font>  </p><p>size为3：<font size="3">size为3</font></p><p>size为4：<font size="4">size为4</font></p><p>size为6：<font size="6">size为6</font></p><hr><h3 id="2-颜色"><a href="#2-颜色" class="headerlink" title="2.颜色"></a>2.颜色</h3><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;font color="#dd0000"&gt;文字颜色&lt;/font&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><font color="#dd0000">文字颜色</font> </p><hr><h3 id="3-背景色"><a href="#3-背景色" class="headerlink" title="3.背景色"></a>3.背景色</h3><p>Markdown 本身不支持背景色设置，需要采用内置 HTMML 的方式实现：借助 <code>table</code> , <code>tr</code> , <code>td</code> 等表格标签的 bgcolor 属性来实现背景色的功能。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF83FA&gt;背景色的设置是按照十六进制颜色值：#FF83FA&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;背景色的设置是按照十六进制颜色值：#D1EEEE&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#C0FF3E&gt;背景色的设置是按照十六进制颜色值：#C0FF3E&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#54FF9F&gt;背景色的设置是按照十六进制颜色值：#54FF9F&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><table><tbody><tr><td bgcolor="orange">背景色是：orange</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FF00FF">背景色的设置是按照十六进制颜色值：#7FFFD4</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FF83FA">背景色的设置是按照十六进制颜色值：#FF83FA</td></tr></tbody></table><table><tbody><tr><td bgcolor="#D1EEEE">背景色的设置是按照十六进制颜色值：#D1EEEE</td></tr></tbody></table><table><tbody><tr><td bgcolor="#C0FF3E">背景色的设置是按照十六进制颜色值：#C0FF3E</td></tr></tbody></table><table><tbody><tr><td bgcolor="#54FF9F">背景色的设置是按照十六进制颜色值：#54FF9F</td></tr></tbody></table><hr><hr><h2 id="使用-LaTex-数学公式"><a href="#使用-LaTex-数学公式" class="headerlink" title="使用 LaTex 数学公式"></a>使用 LaTex 数学公式</h2><hr><h3 id="1-行内公式"><a href="#1-行内公式" class="headerlink" title="1.行内公式"></a>1.行内公式</h3><p>使用两个 <strong>$</strong> 符号引用公式。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$公式$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-行间公式"><a href="#2-行间公式" class="headerlink" title="2.行间公式"></a>2.行间公式</h3><p>使用两对 <strong>$$</strong> 符号引用公式。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$公式$$ <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<a href="https://www.mathjax.org/">Markdown数学符号</a>使用中，详细介绍了一些常用的数学公式。</p><hr><p>更多内容参考 <a href="http://markdown.p2hp.com/basic-syntax/">Markdown 中文网</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Web 编程原理</title>
      <link href="/posts/54137.html"/>
      <url>/posts/54137.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="WEB-编程原理"><a href="#WEB-编程原理" class="headerlink" title="WEB 编程原理"></a>WEB 编程原理</h1><hr><hr><h3 id="Web-服务器的工作过程"><a href="#Web-服务器的工作过程" class="headerlink" title="Web 服务器的工作过程"></a>Web 服务器的工作过程</h3><hr><p>一个 Web 服务器也被称为 HTTP 服务器，它通过 HTTP 协议与客户端进行通信。客户端与服务器之间的通信是非持久连接的，当服务器发送了应答后就与客户端断开连接，等待下一次请求。</p><blockquote><p>浏览器本身是一个客户端，根据用户输入的 URL ，浏览器首先会请求 DNS 服务器，通过 DNS 获取相应域名对应的 IP 。</p></blockquote><blockquote><p>通过 IP 地址找到 IP 对应的服务器后，建立 TCP 连接。</p></blockquote><blockquote><p>浏览器发送完 HTTP Request（请求）包，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回 HTTP Response（响应）包</p></blockquote><blockquote><p>客户端收到来自服务器的响应后开始渲染该 Response 包里的主体（body），客户端收到全部的内容后，断开与该服务器之间的TCP连接。</p></blockquote><hr><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_132934.jpg" alt="访问一个Web站点的过程"></p><p>访问一个 Web 站点的过程：</p><ul><li><p>客户端通过 TCP/IP 协议建立到服务器的 TCP 连接。</p></li><li><p>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档。</p></li><li><p>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端。</p></li><li><p>客户端与服务器断开，由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果。</p></li></ul><hr><h2 id="URI-URL-和-DNS-解析"><a href="#URI-URL-和-DNS-解析" class="headerlink" title="URI , URL 和 DNS 解析"></a>URI , URL 和 DNS 解析</h2><hr><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a><strong>URI</strong></h3><p>URI (Uniform Resource Identifier，统一资源标志符)，用来标识 Web 上每一种可用资源，例如： HTML 文档、图像、视频片段、程序等都由一个 URI 进行标识。</p><p>URI 通常由资源的命名机制，标准存放资源的主机名，资源自身的名称组成。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h3><p>URL（Uniform Resource Locator，统一资源定位符）用于描述一个网络上的资源，基本格式如下：</p><p><code>scheme://host[:port#]/path/.../[?query-string][#anchor]</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">scheme        // 指定低层使用的协议（例如：http, https, ftp）host          // HTTP 服务器的 IP 地址或者域名port          // HTTP 服务器的默认端口是 80（可以省略），如果使用了别的端口，必须指明，例如 http://cqupt.edu.cn:8080/    path         // 访问资源的路径 query-string  // 发送给 http 服务器的数据 anchor        // 锚<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Go 语言中，URL 结构体的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> URI <span class="token keyword">struct</span> <span class="token punctuation">{</span>Scheme <span class="token builtin">string</span>     <span class="token comment">// 方案</span>Opaque <span class="token builtin">string</span>     <span class="token comment">// 编码后的不透明数据</span>User <span class="token operator">*</span>Userinfo    <span class="token comment">// 基本验证方式中 username 和 password 信息 </span>Host <span class="token builtin">string</span>       <span class="token comment">// 主机字段请求头</span>Path <span class="token builtin">string</span>       <span class="token comment">// 路径</span>RawPath <span class="token builtin">string</span>ForceQuery <span class="token builtin">bool</span> RawQuery <span class="token builtin">string</span>   <span class="token comment">// 查询字段</span>Fragment <span class="token builtin">string</span>   <span class="token comment">// 分片字段 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a><strong>DNS 解析</strong></h3><p>DNS（Domain Name System）是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络，将主机名或域名转换为实际 IP 地址。</p><hr><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_132951.jpg" alt="DNS工作原理"></p><p>DNS 解析的整个过程：</p><hr><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_133012.jpg" alt="DNS解析的整个流程"></p><ol><li><p>在浏览器中输入 <code>www.qq.com</code> 域名，操作系统会先检查自己本地的 <code>hosts</code> 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。</p></li><li><p>如果 <code>hosts</code> 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li><li><p>如果 <code>hosts</code> 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器（本地 DNS 服务器），当此服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></li><li><p>如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。</p></li><li><p>如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 “根 DNS 服务器”，“根 DNS 服务器”收到请求后会判断这个域名（.com）由谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP 。本地 DNS 服务器收到 IP 信息后，将会联系负责 <code>.com</code> 域的这台服务器。这台负责 <code>.com</code> 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 <code>.com</code> 域的下一级 DNS 服务器地址（<code>qq.com</code>）给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 <code>qq.com</code> 域服务器，重复上面的动作，进行查询，直至找到 <code>www.qq.com</code> 主机。</p></li><li><p>如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是否转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。</p></li></ol><p>通过上面的步骤，最后获取的是 IP 地址，就是浏览器最后发起请求的时候是基于 IP 来和服务器做信息交互的。</p><hr><h2 id="HTTP-协议详解"><a href="#HTTP-协议详解" class="headerlink" title="HTTP 协议详解"></a>HTTP 协议详解</h2><hr><h3 id="HTTP-协议的基本概念"><a href="#HTTP-协议的基本概念" class="headerlink" title="HTTP 协议的基本概念"></a>HTTP 协议的基本概念</h3><p>超文本传输协议（HTTP）是分布式、协作的、超媒体信息系统的应用层协议。HTTP 是一种让 Web服务器与浏览器（客户端）通过 Internet 发送与接收数据的协议，它建立在 TCP 协议之上，一般采用 TCP 的 <code>80</code> 端口，是一个无状态的请求/响应协议。</p><p>在 HTTP 协议中，客户端总是通过建立一个连接与发送一个 HTTP 请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接，客户端与服务器端都可以提前中断一个连接。</p><h3 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h3><p>客户端发送到服务器端的请求信息由请求行（Request Line），请求（Request Header），请求体（Request Body）组成。 header 和 body 之间有个空行。</p><ul><li>请求行</li></ul><p>请求行由请求方法，URI 、HTTP协议和协议版本组成。</p><table><thead><tr><th align="center">请求方法</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="center">GET</td><td align="left">请求页面，并返回页面内容</td></tr><tr><td align="center">HEAD</td><td align="left">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="center">POST</td><td align="left">大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td align="center">PUT</td><td align="left">从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td align="center">DELETE</td><td align="left">请求服务器删除指定的资源</td></tr><tr><td align="center">OPTIONS</td><td align="left">允许客户端查看服务器的性能</td></tr><tr><td align="center">CONNECT</td><td align="left">把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td align="center">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET、POST、PUT、DELETE 对应着对这个资源的查、改、增、删 4 个操作。</p><hr><p>GET 和 POST 的区别：</p><ol><li><p>GET 一般用于获取/查询资源信息，而 POST 一般用于更新资源信息。GET请求消息体为空，POST请求带有消息体。</p></li><li><p>GET 提交的数据会放在 URL 之后，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连，如<code>EditPosts.aspx?name=test1&amp;id=123456</code> 。POST 方法是把提交的数据放在 HTTP 包的 Body 中。</p></li><li><p>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。</p></li><li><p>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p></li></ol><hr><ul><li>请求头</li></ul><p>请求头包含服务器要使用的附加信息（Cookie 、 Referer 、 User-Agent等）。</p><table><thead><tr><th align="left">请求头</th><th align="left">示 例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">Accept: text/plain,text/html</td><td align="left">指定客户端能够接收的内容类型</td></tr><tr><td align="left">Accept-Charset</td><td align="left">Accept-Charset: iso-8859-5</td><td align="left">浏览器可以接受的字符编码集</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">Accept-Encoding: compress,gzip</td><td align="left">指定浏览器可以支持的 Web 服务器返回内容压缩编码类型</td></tr><tr><td align="left">Accept-Language</td><td align="left">Accept-Language:en,zh</td><td align="left">浏览器可接受的语言</td></tr><tr><td align="left">Accept-Ranges</td><td align="left">Accept-Ranges: bytes</td><td align="left">可以请求网页实体的一个或者多个子范围字段</td></tr><tr><td align="left">Authorization</td><td align="left">Authorization: BasicdbxhZGRpbjpvcGVuIHNIc2Ftyd=</td><td align="left">HTTP授权的授权证书</td></tr><tr><td align="left">Cache-Control</td><td align="left">Cache-Control:no-cache</td><td align="left">指定请求和响应遵循的缓存机制</td></tr><tr><td align="left">Connection</td><td align="left">Connection: close</td><td align="left">表示是否需要持久连接。（HTTP1.1默认进行持久连接）</td></tr><tr><td align="left">Cookie</td><td align="left">Cookie: $Version=1; Skin=new;</td><td align="left">在发送 HTTP 请求时，会把保存在该请求域名下的所有 cookie 值一起发送给 Web 服务器</td></tr><tr><td align="left">Content-Length</td><td align="left">Content-Length:348</td><td align="left">请求的内容长度</td></tr></tbody></table><ul><li>请求体</li></ul><p> 请求体是指在 HTTP 请求中传输数据的实体，常用于 POST 、 PUT 等请求中。</p><h3 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h3><p>HTTP 响应由服务器端返回给客户端，分为响应状态码（Response Status Code）,响应头（Response Header）和响应体（Response Body）。</p><ul><li>状态码</li></ul><p>状态码用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response 。 HTTP/1.1 协议中定义了 5 类状态码，状态码由三位数字组成，第一个数字定义了响应的类别。</p><p>常见状态码类型：</p><blockquote><ul><li>1XX 提示信息——表示请求已被成功接收，继续处理。</li><li>2XX 成功——表示请求已被成功接收，理解，接受。</li><li>3XX 重定向——要完成请求必须进行更进一步的处理。</li><li>4XX 客户端错误——请求有语法错误或请求无法实现。</li><li>5XX 服务器端错误——服务器未能实现合法的请求。</li></ul></blockquote><ul><li>响应头</li></ul><p>响应头包含服务器对请求的应答信息，如 Content-Type 、 Server 、 Set-Cookie 等。</p><table><thead><tr><th align="center">响应头</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="left">服务器支持哪些请求方法（如 GET、POST 等）</td></tr><tr><td align="center">Content-Encoding</td><td align="left">文档的编码（Encode）方法。只有在解码之后才可以得到用 Content-Type 头指定的内容类型。利用 gzip 压缩文档能够显著地减少 HTML 文档的下载时间</td></tr><tr><td align="center">Content-Length</td><td align="left">表示内容长度。只有当浏览器使用持久 HTTP 连接时才需要这个数据</td></tr><tr><td align="center">Content-Type</td><td align="left">表示后面的文档属于什么 MIME 类型</td></tr><tr><td align="center">Date</td><td align="left">当前的 GMT 时间</td></tr><tr><td align="center">Expires</td><td align="left">应该在什么时候认为文档已经过期，从而不再缓存它</td></tr><tr><td align="center">Last-Modified</td><td align="left">文档的最后改动时间。可以通过 If-Modified-Since 请求头提供一个日期，该请求将被视为一个有条件的 GET 请求。只有改动时间迟于指定时间的文档才会返回，否则返回一个 304（Not Modified）状态。</td></tr><tr><td align="center">Last-Modified</td><td align="left">也可用setDateHeader()方法来设置</td></tr><tr><td align="center">Location</td><td align="left">表示客户端应该当到哪里去提取文档，通常不是直接设置的</td></tr><tr><td align="center">Refresh</td><td align="left">表示浏览器应该在多少时间之后刷新文档，以秒计</td></tr><tr><td align="center">Server</td><td align="left">服务器的名字</td></tr><tr><td align="center">Set-Cookie</td><td align="left">设置和页面关联的 Cookie</td></tr><tr><td align="center">WWW-Authenticate</td><td align="left">客户应该在 Authorization 头中提供的授权信息。在包含 401（Unauthorized）状态行的应答中这个信息是必需的</td></tr></tbody></table><ul><li>响应体</li></ul><p>响应体是 HTTP 请求返回的内容，响应的正文数据都在响应体中。</p><hr><h2 id="接收和处理-Go-Web-请求"><a href="#接收和处理-Go-Web-请求" class="headerlink" title="接收和处理 Go Web 请求"></a>接收和处理 Go Web 请求</h2><hr><h3 id="Go-Web服务器工作流程"><a href="#Go-Web服务器工作流程" class="headerlink" title="Go Web服务器工作流程"></a>Go Web服务器工作流程</h3><p>Go Web 服务器请求和响应的流程如下：</p><ul><li><p>客户端发送请求</p></li><li><p>服务器端的多路复用器收到请求</p></li><li><p>多路复用器根据请求的URL找到注册的处理器，将请求交由处理器处理</p></li><li><p>处理器执行程序逻辑，如果必要，则与数据库进行交互，得到处理结果</p></li><li><p>处理密调用模板引擎将指定的模板和上一步得到的结果渲染成客户端可识别的数据格式（通常是 HTML 格式）</p></li><li><p>服务器端将数据通过 HTTP 响应返回给客户端</p></li><li><p>客户端拿到数据，执行对应的操作（如渲染出来呈现给用户）</p></li></ul><hr><h3 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h3><ol><li><strong>ServeMux 和 DefultServeMux</strong></li></ol><p>多路复用器用于转发请求到处理器,会在映射中找出被请求 URL 最为匹配的URL射至相应的处理器。它然后调用与之相对应的处理器的 ServeHTTP 方法来处理请求。</p><p>DefaultServeMux 是 <code>net/http</code> 包中默认提供的一个多路复用器，其实质是 ServeMux 的一个实例，多路复用器的任务是——根据请求的 URL 将请求重定向到不同的处理器。如果用户没有为 Server 对象指定处理器，则服务器默认使用 DefaultServeMux 作为 ServeMux 结构体的实例 ServeMux 也是一个处理器，可以在需要时对其实仪实施处理器串联。默认的多路复用器 DefauliServeMux 其声明语句如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> DefaultServeMux <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultServeMux<span class="token keyword">var</span> defaultServeMux ServeMux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>HandleFunc() 函数用于为指定的 URL 注册一个处理器，HandleFunc() 处理器函数会在内部调用 DefaultServeMux 对象的对应方法，其内部实现如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span> <span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter <span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span>DefaultServeMux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token punctuation">,</span> handler<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过上面的方法体可以看出，http.HandleFunc() 函数将处理器注册到多路复用器中。用默认多路复用器还可以指定多个处理器，其使用方法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"net/http"</span>    <span class="token comment">//定义多个处理器</span>se thanalel <span class="token keyword">struct</span><span class="token punctuation">(</span>j<span class="token keyword">func</span> <span class="token punctuation">(</span>hl <span class="token operator">*</span>handlel<span class="token punctuation">)</span><span class="token function">serveHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>ffmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hi,handlel"</span><span class="token punctuation">)</span><span class="token keyword">type</span> handle2 <span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h2 <span class="token operator">*</span>handle2<span class="token punctuation">)</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hi,handle2"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">1</span>handlel <span class="token operator">:=</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>handle2 <span class="token operator">:=</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//nil表明服务器使用默认的多路复用器DefaultServeMux</span>server<span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">Server</span><span class="token punctuation">(</span>Addr<span class="token punctuation">:</span> “<span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span><span class="token punctuation">:</span><span class="token number">8085</span>"<span class="token punctuation">,</span>Handler<span class="token punctuation">:</span> ngl<span class="token punctuation">,</span><span class="token comment">//hande()函数调用的是多路复用器的</span>DefaultServeMux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法    http<span class="token punctuation">,</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/handlel"</span><span class="token punctuation">,</span>shandle1<span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/handle2"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle2<span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，直接用 http.Handle() 函数来指定多个处理器。Handle() 函数的代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Handle <span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span><span class="token function">Func</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> bandler<span class="token punctuation">)</span><span class="token punctuation">]</span> handler Handler<span class="token punctuation">)</span> DefaultServeMux<span class="token punctuation">.</span>Hardle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过代码可以看到，在 http.Handle() 函数中调用了 DefaultServeMux.Handle() 方法来处理清求服 器收到的每个请求都会调用对应多路复用器的 ServeHTTP( 方法。该方法的代码详情如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> handler serverHandler<span class="token punctuation">)</span><span class="token function">SezveHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req Request<span class="token punctuation">)</span> <span class="token operator">:=</span>sh<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler<span class="token keyword">if</span> handler sx <span class="token boolean">nil</span>handler <span class="token operator">=</span> DefaultServeMuxhandler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 ServeMux 对象的 ServeHTTP()方法中，会根据 URL 查找注册的处理器，然后将请求交由它处理。<br>虽然默认的多路复用器使用起来很方便，但是在生产环境中不建议使用。因为 DefaultServeMux 是一个全局变量，所有代码（包括第三方代码）都可以修改它。有些第三方代码会在  DefaultServeMux 中注册一些处理器，这可能与注册的处理器冲突。比较推荐的做法是自定义多路复用器。<br>自定义多路复用器也比较简单，直接调用  http.NewServeMux() 函数即可。然后，在新创建的多路复用器上注册处理器；</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewSeryeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在上面代码中，创建了一个读超时和写超时均为5s的服务器。</p><p>简单总结一下 ServerMux 实现了 http.Handler 接口的 ServeHTTP(ResponseWriter.*Request) 方法。在创建  Server 时，如果设置 Handler 为空，则使用 DefaultServeMux 作为默认的处理器，而 DefaultServeMux 是 ServerMux 的一个全局变量。</p><ol start="2"><li><strong>ServeMux 的 URL 路由匹配</strong></li></ol><p>在实际应用中，一个 Web 服务器往往有很多的 URL 绑定，不同的URL对应不同的处理器。服务器是决定使用哪个处理器过程：<br>假如现在绑定了 3 个 URL，分别是 /、/hi 和 /hi/web ：</p><ul><li>如果请求的 URL为 /，则调用 / 对应的处理器</li><li>如果请求的 URL 为 /hi ，则调用 /hi 对应的处理器</li><li>如果请求的 URL 为 /hi/web ，则调用 /hi/web 对应的处理器。</li></ul><ol start="3"><li><strong>处理器</strong></li></ol><p>服务路在收到请求后，会根据其 URL 将请求交给相应的多路复用器，多路复用器将请求转发给处理器处理。处理器是实现了 Handler 接口的结构。Handler 接口被定义在 <code>net/http</code> 包中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span><span class="token punctuation">(</span><span class="token keyword">func</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>wResponse<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> r<span class="token operator">*</span>Request<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到，Handler 接口中只有一个 ServeHTTP() 处理器方法。任何实现了 Handle 接口的对象，都可以被注册到多路复用器。</p><ol start="4"><li><strong>处理器函数</strong></li></ol><p>下面以默认的处理器函数 HandleFunc() 为例介绍处理器的使用方法。</p><ul><li>注册一个处理器函数</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> func_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个处理器函数的第 1 个参数表示匹配的路由地址 第 2 个参数表示一个名为 func_name 的方法，用于处理具体业务逻辑。例如，注册一个处理器函数，并将处理器的路由匹配到 hi 函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>定义一个名为 hi 的函数，用来打印一个字符串到浏览器：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hi</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hi Web!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>net/http</code> 包提供了以函数的方式注册处理器，即用HandleFunc() 函数来注册处理器，如果一个函数实现了匿多函数 func(w http.ResponseWriter,r *http.Request) ，则这个函数被为为“处理器函数”。 HandleFunc() 函数内部调用了 ServeMux 对象的 Handlefunc() 方法。ServeMux 对象的 HandleFunc() 方法具体代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">m Haudlet<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> Hand1eFunc <span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span> <span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Reguest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">(</span>panichttpiil hanale居历ihHamalermux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>handlex<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续查看内部代码可以发现 HandlerFunc( 函数最终也实现了 Handler 接口的 ServeHTTP() 方法。其实现代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span>ServeHTTP <span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>Handler:处理器接口。定义在 <code>net/http</code> 包中，实现了 Handler 接口的对象，可以生到多路复用器中。</li><li>Handle()：注册处理器过程中的调用函数。</li><li>HandleFunc()：处理器函数。</li><li>HandlerFunc:底层为 func (w ResponseWriter,r*Request) 匿名函数，实现了 Handler 处理器接口。它用来连接处理器函数与处理器。<br>简而言之 HandlerFunc() 是一个处理器函数，其内部通过对 ServeMux 中一系列方法的调用最终在底层实现了 Handler 处理器接口的 SepveHTTP) 方法，从而实现处理器的功能。</li></ol><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><ol><li><strong>Request</strong></li></ol><p>Request 是 http 请求，用于返回 HTTP 请求的报文，里面包含了浏览器端的相关信息。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">{</span>Method <span class="token builtin">string</span> <span class="token comment">//请求的方法</span>URL <span class="token operator">*</span>url<span class="token punctuation">.</span>URL <span class="token comment">//请求报文中的 URL 地址，是指针类型Proto string //形如："HTTP/1.0”</span>ProtoMajorint <span class="token comment">//1</span>ProtoMinorint <span class="token comment">//0</span>Header Header <span class="token comment">// 请求头字段</span>Bodyio<span class="token punctuation">.</span>ReadCloser <span class="token comment">// 请求体</span>GetBody <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>ContentLength <span class="token builtin">int64</span>TransferEncoding <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token comment">//</span>Close <span class="token builtin">bool</span>Host <span class="token builtin">string</span>请求报文中的一些参数，包括表单字段等Form url<span class="token punctuation">.</span>ValuesPostForm url<span class="token punctuation">.</span>ValuesMultipartForm <span class="token operator">*</span>multipart<span class="token punctuation">.</span>FormTrailer HeaderRemoteAddr <span class="token builtin">string</span>RequestURI <span class="token builtin">string</span>TLS <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionStateCancel <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Response <span class="token operator">*</span>Responsectx context<span class="token punctuation">.</span>Context<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Reauest 结构体主要用于返回.话同的应，只有正确也解行真越数屏、才能内客户端返回响应。接下来通过简单示例来测过一下。下方是 Go 服务器端的代码，用于解析 Request 结构体中各成员(或者说是属性)。代码: </p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span>（<span class="token string">"fmt"</span><span class="token string">"log"</span><span class="token string">"net/http"</span><span class="token string">"strings"</span><span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token comment">//这些信息是输出到服务器端的打印信息</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Request解析"</span><span class="token punctuation">)</span><span class="token comment">//HTTP方法</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"method"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Method<span class="token punctuation">)</span><span class="token comment">//RequestURI是被客户端发送到服务器端的请求行中未修改的请求</span>URIfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"RequestURI:"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>RequestURI<span class="token punctuation">)</span><span class="token comment">//URL 类型，下方分别列出URL的各成员</span>fnt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL_path"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>fnt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL RawQuery"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>RawQuery<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL_Fragment"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Fragment<span class="token punctuation">)</span><span class="token comment">//协议版本</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"proto"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>Proto<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"protomajor"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>ProtoMajor<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"protominor"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ProtoMinor<span class="token punctuation">)</span><span class="token comment">//HTTP请求头</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>Header一<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> vv <span class="token operator">:=</span> <span class="token keyword">range</span> v <span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"header key:"</span><span class="token operator">+</span> k<span class="token operator">+</span><span class="token string">"value:"</span><span class="token operator">+</span> vv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//判断是否为multipart方式</span>isMultipart<span class="token operator">:=</span> <span class="token boolean">false</span><span class="token keyword">for</span> <span class="token punctuation">,</span> v<span class="token operator">:=</span><span class="token keyword">range</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Content-Type"</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token string">"multipart/form-data"</span><span class="token punctuation">)</span> ！<span class="token operator">=</span><span class="token operator">-</span><span class="token function">1</span><span class="token punctuation">(</span>isMultipart <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">(</span>解析 Form表单<span class="token keyword">if</span> isMultipart <span class="token operator">==</span> <span class="token boolean">true</span> r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"解析方式:ParseMultipartForm"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span> （r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"解析方式：ParseForm"</span><span class="token punctuation">)</span><span class="token comment">//HTTP Body 内容长度</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ContentLength"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ContentLength<span class="token punctuation">)</span><span class="token comment">//是否在回复请求后关闭连接</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Close"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Close<span class="token punctuation">)</span><span class="token comment">//HOST</span>fmt<span class="token punctuation">.</span>Prin host"<span class="token punctuation">,</span>r<span class="token punctuation">.</span>Host<span class="token punctuation">)</span><span class="token comment">//该请求的来源地班</span>fmt<span class="token punctuation">.</span><span class="token function">PrintIn</span><span class="token punctuation">(</span><span class="token string">"RemoteAddr"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>RemoteAddr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hello, let's go!"</span><span class="token punctuation">)</span> <span class="token comment">//这个是输出到客户端的</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span>request<span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8081"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"ListenAndServe:"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请求头和响应头使用 Header 类型表示。Header 类型是一个映射(map)类型，表示 HTTP 请求头中的多个键值对。其定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Header <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过请求对象的 Header 属性可以访问到请求头信息。Header 属性是映射结构，提供了 Get() 方法以获取 key 对应的第一个值。Get() 方法的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Header 结构体的其他常用方法的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span><span class="token function">Set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 设置头信息</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span><span class="token function">Add</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">//添加头信息</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Del</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">//删除头信息</span><span class="token keyword">func</span><span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token comment">//使用线模式(in wire format)写头信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请求体和响应体都由 Request 结构中的 Body 字段表示。 Body 字段是一个 <code>io.ReadCloser</code> 接口。<code>ReadCloser</code> 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ReadCloser <span class="token keyword">interface</span> <span class="token punctuation">{</span>ReaderCloser<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Body 字段是 <code>Reader</code> 接口和 <code>Closer</code> 接口的结<br>合。<code>Reader</code> 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token function">Read</span><span class="token punctuation">(</span>P <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过 Reader 接口可以看到，Read() 方法实现了 ReadCloser 接口。所以，可以通过 Body.Read() 方法来读取请求体信息接下来通过示例来加深对 Body.Read() 方法的理解。</p><ul><li><strong>Response</strong></li></ul><p>Response 是 http 请求的响应，包含返回给浏览器端的数据。</p><p>共结构体定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Response <span class="token keyword">struct</span> <span class="token punctuation">{</span>Status <span class="token builtin">string</span> <span class="token comment">// e.g. "200OK"</span>StatusCode <span class="token builtin">int</span> <span class="token comment">// e.g. 200</span>Proto <span class="token builtin">string</span> <span class="token comment">// e.g. "HTTP/1.0"</span>ProtoMajor <span class="token builtin">int</span> <span class="token comment">// e.g. 1</span>ProtoMinor <span class="token builtin">int</span> e<span class="token punctuation">.</span>g<span class="token punctuation">.</span> <span class="token number">0</span>Header HeaderBody io<span class="token punctuation">.</span>ReadCloserContentLength <span class="token builtin">int64</span>TransferEncoding<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>Close <span class="token builtin">bool</span>Uncompressed <span class="token builtin">bool</span>Trailer HeaderRequest <span class="token operator">*</span>RequestTLS <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionState<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>ResponseWriter 原理</strong></li></ol><p>Co 语言对接口的实现，不需要显式的声明，只要实迎了被口定义的方法，那就实现了相应的接口。<br> <code>io.Wrter</code> 是一个接口类型。如果要使用 <code>io.Writer</code>  接口的 Write() 方法，则需要实现 Wrte([]byte) (n int, err error) 方法。<br>在 Go 语言中，客户端请求信息都被封装在 Request 对象中。但是发送给客户端的响应并不是 Response 对象，而是 ResponseWriter 接口。ResponseWriter 接口是处理器用来创建 HTTP 响应的接口的。ResponseWriter 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ResponseWriter <span class="token keyword">interface</span> <span class="token operator">/</span><span class="token number">1</span> 用于设置或者获取所有响应头信息Header <span class="token punctuation">(</span><span class="token punctuation">)</span> Header<span class="token comment">// 用于写入数据到响应体中</span><span class="token function">Write</span><span class="token punctuation">(</span>lJbyte<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1</span> 用于设置响应状态码<span class="token function">WriteHeader</span><span class="token punctuation">(</span>statusCode <span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，在底层支撑 ResponseWriter 接口的是http.response 结构体。在调用处理器处理 HTTP 请求时，会调用 readRequest() 方法 readRequest() 方法会声明response结构体，并且其返回值是 response 指针这也是在处理器方法声明时，Reqyest 是指针类型，而 ResponseWriter 不是指针类型的原因。实际上，响应对象也是指针类型。<br>核心代码如下： readRequest()方法的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">//此处省略若干代码</span>w<span class="token operator">=</span> <span class="token operator">&amp;</span>responsef 走明C<span class="token punctuation">.</span>conn<span class="token punctuation">:</span>cancelCtx<span class="token punctuation">:</span> cancelCtx<span class="token punctuation">,</span>req<span class="token punctuation">:</span> req<span class="token punctuation">,</span>regBody<span class="token punctuation">:</span> req<span class="token punctuation">.</span>Body<span class="token punctuation">,</span>handlerHeader<span class="token punctuation">:</span><span class="token builtin">make</span> <span class="token punctuation">(</span>Header<span class="token punctuation">)</span><span class="token punctuation">,</span>contentLength<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>closeNotifyCh<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>wants10KeepAlive<span class="token punctuation">:</span> req<span class="token punctuation">.</span><span class="token function">wantsHttp10KeepAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>wantsClose<span class="token punctuation">:</span> req<span class="token punctuation">.</span><span class="token function">wantsClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">if</span> isH2Upgradefw<span class="token punctuation">.</span>closeAfterReply <span class="token operator">=</span> <span class="token boolean">true</span>w<span class="token punctuation">.</span>cw<span class="token punctuation">.</span>res <span class="token operator">=</span>ww<span class="token punctuation">.</span>w <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">.</span>cw<span class="token punctuation">,</span> bufferBeforeChunkingSize<span class="token punctuation">)</span><span class="token keyword">return</span> w<span class="token punctuation">,</span> <span class="token boolean">nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>response 结构体的定义和 ResponseWriter 接口都位于 server.go 文件中。不过由于 response 结构体是私有的，对外不可见，所以只能通过 ResponseWriter 接口访问它。两者之间的关系是：ResponseWriter 是一个接口，而 response 结构体实现了。我们引用 ResponseWriter 接口，实际上引用的是 response 结构体的实例。</p><p>ResponseWriter 接口包含 WriteHeader()、Header()、Write() 三个方法来设置响应状态码。</p><ul><li><p>WriteHeader() 方法<br>WrteHeader()方法支持传入一个整型数据来表示响应状态码。如果不调用该方法，则默认响应状态码是200。 WriteHeader() 方法的主要作用是在 API 接口中返回错误码。例如，可以自定义一个处理器方法 noAuth()，并通过w.WriteHeader()方法返回一个401未认证状态码(注意，在运行时，w代表的是对应的response对象实例，而不是接口)。</p></li><li><p>Header()方法<br>Header()方法用于设置响应头。可以通过wHeader().Set()方法设置响应头。w.Header()方法返回的是Header 响应头对象，它和请求头共用一个结构体。因此在请求头中支持的方法这里都支持，比如可以通过w.Header().Add(方法新增响应头。<br>例如，如果要设置一个301重定向响应，则只需要通过w.WriteHeader()方法将响应状态码设置为301，再通过w.Header().Set()方法将“Location”设置为一个可访问域名即可。</p></li></ul><p>提示<br>w.Header(.Set(方法应在 w.WriteHeader(方法之前被调用，因为一旦调用了w.WriteHeaderO方法，就不能对响应头进行设置了。</p><ul><li>Wite() 方法<br>Write() 方法用于将数据写入 HTTP 响应体中。如果在调用Write() 方法时还不知道 Coment-Te 真型，则可以通过数据的前512个 byte 进行判断。用 Write()方法可以返回字符毫数据也可以返回 HTML 文档和 JSON 等常见的文本格式。</li></ul><ul><li>Conn</li></ul><p>Conn是http的请求连接。</p><ul><li>Handler</li></ul><p>Handler是接收请求后逻辑处理和生成返回信息的逻辑。</p><hr><h2 id="http包运行机制"><a href="#http包运行机制" class="headerlink" title="http包运行机制"></a>http包运行机制</h2><hr><p>1.创建Listen Socket，监听指定的端口，等待客户端请求到来。<br>2.Listen Socket接受客户端的请求, 得到Client Socket，接下来通过Client Socket与客户端通信。<br>3.处理客户端的请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还可能要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完毕准备好客户端需要的数据，通过Client Socket写给客户端。</p><hr><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_133058.jpg" alt="Go语言中http包的运行示意图"></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1.</span> <span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token punctuation">{</span><span class="token number">2.</span><span class="token keyword">defer</span> <span class="token number">1.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">3.</span> <span class="token keyword">var</span> tempDelay time<span class="token punctuation">.</span>Duration<span class="token comment">// how long to sleep on accept failure</span><span class="token number">4.</span> <span class="token keyword">for</span><span class="token punctuation">{</span><span class="token number">5.</span> rw<span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token number">1.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">6.</span> <span class="token keyword">if</span> e ！<span class="token operator">=</span><span class="token boolean">nil</span> <span class="token punctuation">(</span><span class="token number">7.</span> <span class="token keyword">if</span> ne<span class="token punctuation">,</span> ok <span class="token operator">:=</span> e<span class="token punctuation">.</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> ne<span class="token punctuation">.</span><span class="token function">Temporary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">8.</span><span class="token keyword">if</span> tempDelay<span class="token operator">=</span><span class="token number">5</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token number">10.</span> tempDelay<span class="token operator">*=</span><span class="token number">2</span><span class="token number">11.</span> <span class="token punctuation">)</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">;</span> tempDelay <span class="token operator">&gt;</span> max：<span class="token operator">=</span><span class="token number">1</span><span class="token number">12.</span> <span class="token number">13.</span> <span class="token keyword">if</span> max tempDelay <span class="token operator">=</span> max 【<span class="token number">14.</span> <span class="token punctuation">)</span><span class="token number">15.</span> log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"http: Accept error: 8v; retrying in Bv"</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> tempDelay<span class="token punctuation">)</span><span class="token number">16.</span> time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>tempDelay<span class="token punctuation">)</span><span class="token number">17.</span> <span class="token keyword">continue</span><span class="token number">18.</span><span class="token number">19.</span> <span class="token keyword">return</span> e<span class="token number">21.</span> <span class="token number">20.</span> tempDelay <span class="token operator">=</span><span class="token number">0</span><span class="token number">22.</span><span class="token number">23.</span> c<span class="token punctuation">,</span> err：<span class="token operator">=</span>srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">(</span><span class="token number">24.</span><span class="token keyword">continue</span><span class="token number">25.</span><span class="token number">26.</span><span class="token number">27.</span> <span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">28.</span> <span class="token punctuation">}</span><span class="token number">29.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这段源码可以看到 Go 语言对于整个 http 请求的处理过程。<br>Server的Serve(l net.Listener)方法就是用于监听和处理http请求的。从第4行开始，函数中就开始了一个for循环，第5行通过参数Listener的Accept接收请求，然后在第23行基于接收的信息新建一个Conn，最后第27行启动一个goroutine来单独为一个Conn服务，不影响其他的Conn是并发的体现。</p><p>整个的过程中，我们只要了解清楚下面三个问题，也就知道Go语言是如何让Web运行起来了。</p><p>● 如何监听端口？● 如何接收客户端请求？● 如何分配handler？从前面小节的代码里面我们可以看到，Go 语言是通过一个函数来操作这个事情的ListenAndServe来监听的，这个底层其实这样处理的：初始化一个server对象，调用net. Listen(“tcp”, addr)，也就是底层用TCP协议搭建了一个服务，然后监控我们设置的端口。<br>监控之后如何接收客户端的请求呢？上面代码执行监控端口之后，调用了srv.Serve(net.Listener)函数，这个函数就是处理接收客户端的请求信息。这个函数里面起了一个 for{}，首先通过 Listener 接收请求，其次创建一个 Conn，最后单独开了一个goroutine，把这个请求的数据当做参数扔给这个conn去服务：go c.serve()。即成高并发体现，用户的每一次请求都是在一个新的goroutine去服务，相互不影响。<br>那么如何具体分配到相应的函数来处理请求呢？conn 首先会解析request:c.readRequest()，然后获取相应的handler:handler := c.server.Handler，也就是我们刚才在调用函数 ListenAndServe 时候的第二个参数，我们前面例子传递的是 nil，也就是为空，默认获取handler = DefaultServeMux，那么用这个变量做什么的呢？对，这个变量就是一个路由器，它用来匹配url跳转到其相应的handle函数。我们调用的代码里面第一句就调用了http.HandleFunc(“/“, sayhelloName)。这个作用就是注册了请求/的路由规则，当请求 uri 为”/“，路由就会转到函数 sayhelloName，DefaultServeMux 会调用ServeHTTP方法，这个方法内部其实就是调用sayhelloName本身，最后通过写入response的信息反馈到客户端。详细的流程如图3.10所示。</p><p><img src="https://tao7app.files.wordpress.com/2023/01/weread_image_87940054354055.jpeg"></p><p>至此，三个问题已经全部得到了解答，你现在对于Go语言如何让Web跑起来是否已经有基本了解？</p><hr><h2 id="Go语言的http包详解"><a href="#Go语言的http包详解" class="headerlink" title="Go语言的http包详解"></a>Go语言的http包详解</h2><hr><ol><li><strong>Handler</strong></li></ol><p>net/http包的Handle和HandleFunc这两个函数的作用。这两个函数都是接收两个参数：第一个参数都是pattern(请求路径)，因为其效果都是给路径绑定处理函数，所以两个函数的作用是一样的；对于第二个参数，一个是Handler接口类型，也就是说只要实现了该接口的函数都可以作为第二个参数传人；另一个则是以函数类型作为参数，只要传入的函数以func(http.ResponseWriter，*http.Request)形式声明就可以。因为ServeHttp的声明满足HandleFunc第二个参数的要求，所以上面代码中第6行可以改为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">th <span class="token operator">:=</span> <span class="token function">ThisHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>th<span class="token punctuation">.</span>ServeHttp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>虽然上面的两个函数在使用的时候有些区别，但是对于Co语言的底层实现来说并无二.，都是交给DcfaultServeMux来完成处理函数和路由的绑定。</p><ol start="3"><li><strong>ServerMux</strong></li></ol><p>DefualtSeveMux也提供了DefaultServeMux handle和DefaulterveMux handleFunc这两个函数。可用它们把http Handle和http.andleFunc的patern和Handler函数绑定到ServerMux上。DefaultServeMux是ServerMux的实例对象，下面来看一下ServerMux的结构体定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span><span class="token punctuation">(</span>mu sync<span class="token punctuation">.</span>RWMutex<span class="token comment">// 读写锁</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry<span class="token comment">//路由 map, pattern-&gt;HandleFunc</span>hosts <span class="token builtin">bool</span><span class="token comment">// 是否包含 hosts</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span><span class="token punctuation">(</span>explicit <span class="token builtin">bool</span><span class="token comment">//是否精确匹配，http包内都使用ture</span>h Handler <span class="token comment">// 路由对应的Handler</span>pattern <span class="token builtin">string</span><span class="token comment">// 路由</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的路由和handler的绑定最终都存储到这里。因为http包内仅支持精确匹配，所以使用标准的net/http包不能直接配置带参数的路由，只能配置参数前面的路径，然后在handler内部再处理。也可以借助第三方包，比如httprouter。</p><ol start="3"><li><strong>Server</strong></li></ol><p>在配置好路由、处理函数以后，接下来就要启动服务，可使用如下代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>"<span class="token punctuation">:</span><span class="token number">8080</span>°<span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数是监听的端口，以字符串的形式传递；第二个参数是handler，传入的是il该语句执行完毕后就开始监听8080端口，来看一下该函数的源码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">LiatenAndserve</span><span class="token punctuation">(</span>addrstringrhandler Handler<span class="token punctuation">)</span><span class="token builtin">error</span><span class="token punctuation">[</span>server te <span class="token function">aServer</span><span class="token punctuation">(</span>Addr<span class="token punctuation">:</span>addr<span class="token punctuation">:</span>Handler<span class="token punctuation">:</span> handler<span class="token punctuation">)</span><span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出，该方法首先要做的就是创建 Server 的实例，并且调用其 ListenAndServe方。可见Server非常重要，下面来看一下Server的结构体：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1.</span> <span class="token keyword">type</span> Server atruct监听的地址和婚口Addr <span class="token builtin">string</span><span class="token number">3.</span> <span class="token number">2.</span> Bandler Bandler <span class="token comment">// handlerto invoke, http.DefaultServeMuxif nil</span>TLSContig<span class="token operator">*</span>tls<span class="token punctuation">.</span>Config <span class="token operator">/</span><span class="token number">1</span> 读超时时间<span class="token number">5.</span> ieadTineouttime<span class="token punctuation">.</span>Durationtime<span class="token punctuation">.</span>Doration <span class="token comment">// 读关文件超时时间</span><span class="token number">6.</span> ReadieaderTineout<span class="token number">7.</span> writeTimeouttime<span class="token punctuation">.</span>Duration <span class="token comment">//写超时时间</span><span class="token number">8.</span> IdleTimoout time<span class="token punctuation">.</span>Duration<span class="token number">9.</span> HaxlleaderBytesint<span class="token number">10.</span> TLSNextProtonap<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token operator">*</span>tls<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> Handler<span class="token punctuation">)</span><span class="token number">12.</span> ConnState <span class="token keyword">func</span> <span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> ConnState<span class="token punctuation">)</span><span class="token number">12.</span> ErrorLog ·log<span class="token punctuation">.</span>Logger<span class="token number">13.</span><span class="token number">14.</span> BaseContextfunc <span class="token punctuation">(</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> context<span class="token punctuation">.</span>ContextConnContext <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context<span class="token number">25.</span><span class="token number">16.</span> disableKeepAlivesint32 accessed atomically<span class="token punctuation">.</span><span class="token number">17.</span> inShut<span class="token punctuation">.</span>dowm <span class="token builtin">int</span> <span class="token number">32</span> accessedatomically <span class="token punctuation">(</span>non<span class="token operator">-</span>zero means we're in<span class="token number">18.</span><span class="token number">19.</span> nextProtoonce sync<span class="token punctuation">.</span>Once <span class="token comment">// guards setupHTTP2</span>init<span class="token number">11</span> http2<span class="token punctuation">.</span>ConfigureServerShutdown<span class="token punctuation">)</span><span class="token number">20.</span> nextProtoErr erTor result of <span class="token keyword">if</span> used<span class="token number">21.</span> mu sync<span class="token punctuation">,</span>Mutex<span class="token number">22.</span><span class="token number">23.</span> 1isteners <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token operator">*</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">24.</span> activeConndoneChan <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token operator">*</span>conn<span class="token punctuation">)</span><span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">25.</span> onShutdownchan<span class="token punctuation">(</span><span class="token function">lfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">26.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看一下Server的三个方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>srv<span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">ListenAndServeTLS</span><span class="token punctuation">(</span>certFile<span class="token punctuation">,</span> keyFile <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中Serve方法在9.1.1节已经详细介绍过，此处不再赘述。<br>ListenAndServe方法的作用是开启http Server服务。ListenAndServeTLS方法的作用是开启https Server服务。</p><p>RespomseWriter:生成 Response的接口。<br>ServerMux：路由处理函数，这个刚刚介绍过。<br>在Serve方法执行完成后，就执行Conn(连接)的Serve方法，然后再通过Conn的readRequest方法获取Response。从逻辑上来说，c.serve方法就是完成这个功能的，此处我们需关注以下三个接口。</p><p>(1)ResponseWriter接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ResponseWriter <span class="token keyword">interface</span><span class="token comment">// Beader 方法返回 Response 返回的 Header 供读写</span>Header <span class="token punctuation">(</span><span class="token punctuation">)</span> Header<span class="token comment">// Write 方法写 Response 的 Body</span><span class="token function">Write</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// WriteHeader 方法根据 HTTP状态码来写 Response的Header</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该接口的主要作用是供Handler函数调用，用来生成要返回的Response。<br>(2)Flusher接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Flusher <span class="token keyword">interface</span> t<span class="token number">1</span><span class="token operator">/</span>刷新缓存区Cotter <span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该接口的主要作用是供Handler调用，将写缓存中的数据刷新到客户端。<br>(3)Hijacker接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Hijacker <span class="token keyword">interface</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> Hijacker <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> <span class="token operator">*</span>bufio<span class="token punctuation">.</span>ReadWriter<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该接口的主要作用是供Handler调用，用以关闭连接。<br>以上是Handler在执行过程中最常用、最重要的三个接口，正是这三个接口使Handler可以在处理完逻辑后把结果写回客户端，稍后会介绍实现这三个接口的对象。<br>通过对Server的介绍，读者可以知道如何在接受请求后调用Handler并且生成response。 response生成以后数据是如何写到客户端的呢？接下来我们开始了解response。<br>4.response<br>下面的方法用于把数据写给客户端：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">serverHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Server<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>w<span class="token punctuation">.</span>req<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该语句最终触发了路由绑定，w是response的实例对象(此处的w是ResponseWriter接口)，response实现了 ResponseWriter、Flusher、Hijacker接口。<br>来看一下response结构体的定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1.</span> <span class="token keyword">type</span> response <span class="token keyword">struct</span>conn <span class="token operator">*</span>conn <span class="token comment">//保存此次HTTP连接的信息</span><span class="token comment">//对应请求信息</span><span class="token operator">*</span>Request<span class="token number">4.</span> <span class="token number">2.</span> <span class="token number">3.</span> regchunking <span class="token builtin">bool</span> <span class="token comment">//是否使用chunk</span><span class="token number">5.</span> wroteHeaderbool <span class="token comment">// header是否已经执行过写操作</span><span class="token number">6.</span> wroteContinuebool <span class="token comment">//100 Continue response was written</span><span class="token number">7.</span> header Header <span class="token operator">/</span> <span class="token operator">/</span> 返回的 HTTP的Header<span class="token number">8.</span> written <span class="token builtin">int64</span> <span class="token comment">// Body的字节数</span><span class="token number">9.</span> contentLength <span class="token builtin">int64</span> <span class="token comment">// Content 长度</span>HTTP状态<span class="token number">10.</span>status<span class="token comment">//</span><span class="token number">11.</span> needSniffboolint<span class="token number">1</span><span class="token operator">/</span>是否开启sniff。若不设置Content<span class="token operator">-</span>Type，开启sniff能自动确定Content<span class="token operator">-</span>Type <span class="token operator">/</span><span class="token number">1</span> 是否保持长链接。若request有keep<span class="token operator">-</span>alive，该字<span class="token number">12.</span> closeAfterReplybool段就设置为<span class="token boolean">false</span>。 是否requestBody太大。当requestBody太大时，<span class="token number">13.</span> requestBodyLimitHitbool <span class="token comment">//</span>response 返回 <span class="token number">411</span><span class="token number">14.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器端需要返回给客户端的所有信息都包含在response中。<br>再来看一下response的主要方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Header<span class="token keyword">func</span><span class="token punctuation">(</span>w<span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>code <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>w<span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">Write</span><span class="token punctuation">(</span>data <span class="token punctuation">(</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>w<span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">WriteString</span><span class="token punctuation">(</span>data <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// either dataB or dataS is non-zero.</span><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">write</span><span class="token punctuation">(</span>lenDataint<span class="token punctuation">,</span> dataB <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> dataS <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">finishRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Hijack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rwcnet<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> buf <span class="token operator">*</span>bufio<span class="token punctuation">.</span>ReadWriter<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，response确实实现了ResponseWriter、Flusher、Hijacker三个接口，有了这三个接口，response就可以把处理结果写回客户端。</p><ol start="5"><li> ServeHTTP(w,w.req)<br>前面介绍了如何通过 response把数据写回客户端，不过Handler如何生成response目前还没有介绍，其实非常简单，来看Handler接口：</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span><span class="token punctuation">(</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>具体的逻辑函数<br>在实现Handler接口的时候，就意味着已经有处理请求逻辑的函数了。serverHandle通过ServeHTTP来选择触发HandleFunc，此处有一个判断，如果有自定义的Handler函数就调用自己的，如果是nil则使用默认的DefaultServeMux。下面来梳理这个流程。<br>DefaultServeMux.ServeHttp的执行流程如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">i<span class="token punctuation">.</span> h<span class="token punctuation">,</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>ii<span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>者对这些内容的理解，此处再从执行流程上梳理一下，整体流程如下。<br>第一步：调用http.HandleFunc注册路由和对应处理函数。<br>第二步：先后调用DefaultServeMux的HandleFunc和Handle，并且向handler(也就是map[string]muxEntry)中注册路由和对象的函数。<br>第三步：实例化 Server，并调用ListenAndServe。<br>第四步：调用net.Listen(“tcp”，addr)，等待请求，每一个请求创建一个Conm，并且启动一个goroutine处理请求。<br>第五步：通过readRequest方法读取请求内容，或者说response的取值过程。<br>第六步：进入serveHandler.ServeHTTP，ServeHTTP方法内会判断有没有自定义的handler，如果没有则使用默认的DefaultServeMux。<br>第七步：调用handler(或DefaultServeMux)的ServeHTTP方法。<br>第八步：通过request选择匹配的handler，遍历muxEntry，寻找满足这个Request的路由。如果找到满足条件的路由，调用对象handler的ServeHTTP；如果没有找到满足条件的路由，调用NotFoundHandler的ServeHTTP。<br>以上就是http包的大致工作流程。为便于读者清晰理解，这里把核心源码按照功能整理如下。<br>(1)路由注册对应的源码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span>HandlerFunc<span class="token punctuation">:</span><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> ServeHTTP <span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token keyword">func</span> HandleFunc <span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span>accern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> http<span class="token punctuation">.</span>Handle<span class="token punctuation">:</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)接口监听相关源码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span><span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(3)接收客户端请求<br>Server的Serve方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Server的newConn方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">newConn</span><span class="token punctuation">(</span>rwc net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span>conn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(4)分配Handler</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fune <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span>serve <span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">readRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req Request<span class="token punctuation">)</span>DefaultServeMux<span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span><span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span>Handler接口的定义：<span class="token keyword">type</span> Handler <span class="token keyword">interface</span>ServeMux<span class="token punctuation">.</span>ServeHTTP<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span><span class="token function">ServelITTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span><span class="token function">Handler</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> handler <span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言的http有两个核心功能：Conn和ServeMux。</p><h3 id="Conn的goroutine"><a href="#Conn的goroutine" class="headerlink" title="Conn的goroutine"></a>Conn的goroutine</h3><p>Go 语言为了实现高并发和高性能, 使用goroutines处理Conn的读写事件，这样每个请求都能保持独立，相互不会阻塞，以高效响应网络事件。</p><p>Go语言在等待客户端请求时写下如下代码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">c<span class="token punctuation">,</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        <span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端的每次请求都会创建一个Conn，这个Conn里面保存了该次请求的信息，然后再传递到对应的handler，该handler中便可以读取到相应的header信息，以保证了每个请求的独立性。</p><h3 id="ServeMux的自定义"><a href="#ServeMux的自定义" class="headerlink" title="ServeMux的自定义"></a>ServeMux的自定义</h3><p>conn.server内部调用了http包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>            mu sync<span class="token punctuation">.</span>RWMutex   <span class="token comment">//锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span>            m  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry  <span class="token comment">// 路由规则，一个 string 对应一个 mux 实体，这里的string就是注册的路由表达式</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>muxEntry结构体定义。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span> <span class="token punctuation">{</span>            explicit <span class="token builtin">bool</span>   <span class="token comment">// 是否精确匹配</span>            h       Handler <span class="token comment">// 这个路由表达式对应哪个handler</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Handler的定义，Handler是接收请求后逻辑处理和生成返回信息的逻辑。。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>            <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>  <span class="token comment">// 路由实现器</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>调用了 HandlerFunc(f)，类似强制类型转换 f 成为HandlerFunc类型，这样f就拥有了ServHTTP方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>        <span class="token comment">// ServeHTTP calls f(w, r).</span>        <span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>路由器接收到请求之后调用mux.handler(r).ServeHTTP(w, r)，也就是调用对应路由的handler的ServerHTTP接口，那么mux.handler(r)怎么处理的呢？根据用户请求的URL和路由器里面存储的map去匹配的，当匹配到之后返回存储的handler，调用这个handler的ServHTTP接口就可以执行到相应的函数了。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> Handler <span class="token punctuation">{</span>            mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">// Host-specific pattern takes precedence over generic ones</span>            h <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Host <span class="token operator">+</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>            <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                h <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                h <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> h        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 语言其实支持外部实现的路由器 ListenAndServe的第二个参数就是用以配置外部路由器的，它是一个Handler接口，即外部路由器只要实现了 Handler 接口就可以，我们可以在自己实现的路由器的ServHTTP里面实现自定义路由功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>            <span class="token string">"fmt"</span>            <span class="token string">"net/http"</span>        <span class="token punctuation">)</span>        <span class="token keyword">type</span> MyMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>MyMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path <span class="token operator">==</span> <span class="token string">"/"</span> <span class="token punctuation">{</span>                <span class="token function">sayhelloName</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token punctuation">}</span>            http<span class="token punctuation">.</span><span class="token function">NotFound</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">func</span> <span class="token function">sayhelloName</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello myroute!"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mux <span class="token operator">:=</span> <span class="token operator">&amp;</span>MyMux<span class="token punctuation">{</span><span class="token punctuation">}</span>            http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":9090"</span><span class="token punctuation">,</span> mux<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言代码的执行流程<br>通过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。<br>1.首先调用Http.HandleFunc，按顺序做如下操作。<br>● 调用了DefaultServerMux的HandleFunc。<br>● 调用了DefaultServerMux的Handle。<br>● 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则。<br>2.其次调用http.ListenAndServe(“:9090”, nil)，按顺序做如下操作。<br>● 实例化Server。<br>● 调用Server的ListenAndServe()。<br>● 调用net.Listen(“tcp”, addr)监听端口。<br>● 启动一个for循环，在循环体中Accept请求。<br>● 对每个请求实例化一个 Conn，并且开启一个 goroutine 为这个请求进行服务 go c.serve()。<br>● 读取每个请求的内容w, err := c.readRequest()。<br>● 判断handler是否为空，如果没有设置handler（这个例子就没有设置handler）， handler就设置为DefaultServeMux。<br>● 调用handler的ServeHttp。<br>● 在这个例子中，下面就进入到DefaultServerMux.ServeHttp。<br>● 根据request选择handler，并且进入到这个handler的ServeHTTP，<br>        <code>mux.handler(r).ServeHTTP(w, r)</code><br>● 选择handler：<br>a.判断是否有路由能满足这个request（循环遍历ServerMux的muxEntry）。<br>b.如果有路由满足，调用这个路由handler的ServeHttp。<br>c.如果没有路由满足，调用NotFoundHandler的ServeHttp。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
