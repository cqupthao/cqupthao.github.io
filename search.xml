<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go Web 编程原理</title>
      <link href="/posts/54137.html"/>
      <url>/posts/54137.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Web-服务器"><a class="header-anchor" href="#Web-服务器">☃</a>Web 服务器</h1><hr><hr><h2 id="Web-服务器的工作过程"><a class="header-anchor" href="#Web-服务器的工作过程">☃</a>Web 服务器的工作过程</h2><hr><p>一个 Web 服务器也被称为 HTTP 服务器，它通过 HTTP 协议与客户端进行通信。客户端与服务器之间的通信是非持久连接的，当服务器发送了应答后就与客户端断开连接，等待下一次请求。</p><blockquote><p>浏览器本身是一个客户端，根据用户输入的 URL ，浏览器首先会请求 DNS 服务器，通过 DNS 获取相应域名对应的 IP 。</p></blockquote><blockquote><p>通过 IP 地址找到 IP 对应的服务器后，建立 TCP 连接。</p></blockquote><blockquote><p>浏览器发送完 HTTP Request（请求）包，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回 HTTP Response（响应）包。</p></blockquote><blockquote><p>客户端收到来自服务器的响应后开始渲染该 Response 包里的主体（body），客户端收到全部的内容后，断开与该服务器之间的TCP连接。</p></blockquote><hr><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_132934.jpg" alt="访问一个Web站点的过程"></p><ul><li><p>客户端通过 TCP/IP 协议建立到服务器的 TCP 连接。</p></li><li><p>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档。</p></li><li><p>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端。</p></li><li><p>客户端与服务器断开，由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果。</p></li></ul><hr><h2 id="URI-URL-和-DNS-解析"><a class="header-anchor" href="#URI-URL-和-DNS-解析">☃</a>URI , URL 和 DNS 解析</h2><hr><h3 id="URI"><a class="header-anchor" href="#URI">☃</a><strong>URI</strong></h3><p>URI (Uniform Resource Identifier，统一资源标志符)，用来标识 Web 上每一种可用资源，例如： HTML 文档、图像、视频片段、程序等都由一个 URI 进行标识。</p><p>URI 通常由资源的命名机制，标准存放资源的主机名，资源自身的名称组成。</p><h3 id="URL"><a class="header-anchor" href="#URL">☃</a><strong>URL</strong></h3><p>URL（Uniform Resource Locator，统一资源定位符）用于描述一个网络上的资源，基本格式如下：</p><p><code>scheme://host[:port#]/path/.../[?query-string][#anchor]</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">scheme        // 指定低层使用的协议（例如：http, https, ftp）host          // HTTP 服务器的 IP 地址或者域名port          // HTTP 服务器的默认端口是 80（可以省略），如果使用了别的端口，必须指明，例如 http://cqupt.edu.cn:8080/    path         // 访问资源的路径 query-string  // 发送给 http 服务器的数据 anchor        // 锚<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Go 语言中，URL 结构体的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> URI <span class="token keyword">struct</span> <span class="token punctuation">{</span>Scheme <span class="token builtin">string</span>     <span class="token comment">// 方案</span>Opaque <span class="token builtin">string</span>     <span class="token comment">// 编码后的不透明数据</span>User <span class="token operator">*</span>Userinfo    <span class="token comment">// 基本验证方式中 username 和 password 信息 </span>Host <span class="token builtin">string</span>       <span class="token comment">// 主机字段请求头</span>Path <span class="token builtin">string</span>       <span class="token comment">// 路径</span>RawPath <span class="token builtin">string</span>ForceQuery <span class="token builtin">bool</span> RawQuery <span class="token builtin">string</span>   <span class="token comment">// 查询字段</span>Fragment <span class="token builtin">string</span>   <span class="token comment">// 分片字段 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DNS-解析"><a class="header-anchor" href="#DNS-解析">☃</a><strong>DNS 解析</strong></h3><p>DNS（Domain Name System）是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络，将主机名或域名转换为实际 IP 地址。</p><hr><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_132951.jpg" alt="DNS工作原理"></p><hr><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_133012.jpg" alt="DNS解析的整个流程"></p><ul><li><p>在浏览器中输入 <code>www.qq.com</code> 域名，操作系统会先检查自己本地的 <code>hosts</code> 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。</p></li><li><p>如果 <code>hosts</code> 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li><li><p>如果 <code>hosts</code> 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器（本地 DNS 服务器），当此服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></li><li><p>如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。</p></li><li><p>如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 “根 DNS 服务器”，“根 DNS 服务器”收到请求后会判断这个域名（<code>.com</code>）由谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP 。本地 DNS 服务器收到 IP 信息后，将会联系负责 <code>.com</code> 域的这台服务器。这台负责 <code>.com</code> 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 <code>.com</code> 域的下一级 DNS 服务器地址（<code>qq.com</code>）给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 <code>qq.com</code> 域服务器，重复上面的动作，进行查询，直至找到 <code>www.qq.com</code> 主机。</p></li><li><p>如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是否转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。</p></li></ul><p>通过上面的步骤，最后获取的是 IP 地址，即浏览器最后发起请求的时候是基于 IP 来和服务器做信息交互的。</p><hr><h2 id="HTTP-协议"><a class="header-anchor" href="#HTTP-协议">☃</a>HTTP 协议</h2><hr><h3 id="HTTP-协议的基本概念"><a class="header-anchor" href="#HTTP-协议的基本概念">☃</a>HTTP 协议的基本概念</h3><p>超文本传输协议（HTTP）是分布式、协作的、超媒体信息系统的应用层协议。HTTP 是一种让 Web服务器与浏览器（客户端）通过 Internet 发送与接收数据的协议，它建立在 TCP 协议之上，一般采用 TCP 的 <code>80</code> 端口，是一个无状态的请求/响应协议。</p><p>在 HTTP 协议中，客户端总是通过建立一个连接与发送一个 HTTP 请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接，客户端与服务器端都可以提前中断一个连接。</p><h3 id="HTTP-请求"><a class="header-anchor" href="#HTTP-请求">☃</a>HTTP 请求</h3><p>客户端发送到服务器端的请求信息由请求行（Request Line），请求（Request Header），请求体（Request Body）组成。 header 和 body 之间有个空行。</p><ul><li><strong>请求行</strong></li></ul><p>请求行由请求方法、URI 、HTTP 协议/协议版本组成。</p><table><thead><tr><th style="text-align:center">请求方法</th><th style="text-align:left">方法描述</th></tr></thead><tbody><tr><td style="text-align:center">GET</td><td style="text-align:left">请求页面，并返回页面内容</td></tr><tr><td style="text-align:center">HEAD</td><td style="text-align:left">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:left">大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td style="text-align:center">PUT</td><td style="text-align:left">从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:left">请求服务器删除指定的资源</td></tr><tr><td style="text-align:center">OPTIONS</td><td style="text-align:left">允许客户端查看服务器的性能</td></tr><tr><td style="text-align:center">CONNECT</td><td style="text-align:left">把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td style="text-align:center">TRACE</td><td style="text-align:left">回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET、POST、PUT、DELETE 对应着对这个资源的查、改、增、删 4 个操作。</p><hr><p>GET 和 POST 的区别：</p><ul><li><p>GET 一般用于获取/查询资源信息，而 POST 一般用于更新资源信息。GET请求消息体为空，POST请求带有消息体。</p></li><li><p>GET 提交的数据会放在 URL 之后，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连，如<code>EditPosts.aspx?name=test1&amp;id=123456</code> 。POST 方法是把提交的数据放在 HTTP 包的 Body 中。</p></li><li><p>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。</p></li><li><p>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p></li></ul><hr><ul><li><strong>请求头</strong></li></ul><p>请求头包含服务器要使用的附加信息（Cookie 、 Referer 、 User-Agent等）。</p><table><thead><tr><th style="text-align:left">请求头</th><th style="text-align:left">示 例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">Accept: text/plain,text/html</td><td style="text-align:left">指定客户端能够接收的内容类型</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">Accept-Charset: iso-8859-5</td><td style="text-align:left">字符编码集</td></tr><tr><td style="text-align:left">Accept-Encoding</td><td style="text-align:left">Accept-Encoding: compress,gzip</td><td style="text-align:left">指定浏览器可以支持的 Web 服务器返回内容压缩编码类型</td></tr><tr><td style="text-align:left">Accept-Language</td><td style="text-align:left">Accept-Language:en,zh</td><td style="text-align:left">浏览器可接受的语言</td></tr><tr><td style="text-align:left">Accept-Ranges</td><td style="text-align:left">Accept-Ranges: bytes</td><td style="text-align:left">可以请求网页实体的子范围字段</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">Authorization: BasicdbxhZGRpbjpvcGVuIHNIc2Ftyd=</td><td style="text-align:left">HTTP 授权的授权证书</td></tr><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">Cache-Control:no-cache</td><td style="text-align:left">指定请求和响应遵循的缓存机制</td></tr><tr><td style="text-align:left">Connection</td><td style="text-align:left">Connection: close</td><td style="text-align:left">表示是否需要持久连接。（HTTP1.1默认进行持久连接）</td></tr><tr><td style="text-align:left">Cookie</td><td style="text-align:left">Cookie: $Version=1; Skin=new;</td><td style="text-align:left">请求域名下的所有 cookie 值</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">Content-Length:348</td><td style="text-align:left">请求的内容长度</td></tr></tbody></table><ul><li><strong>请求体</strong></li></ul><p>请求体是指在 HTTP 请求中传输数据的实体，常用于 POST 、 PUT 等请求中。</p><h3 id="HTTP-响应"><a class="header-anchor" href="#HTTP-响应">☃</a>HTTP 响应</h3><p>HTTP 响应由服务器端返回给客户端，分为响应状态码（Response Status Code）,响应头（Response Header）和响应体（Response Body）。</p><ul><li><strong>状态码</strong></li></ul><p>状态码用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response 。 HTTP/1.1 协议中定义了 5 类状态码，状态码由三位数字组成，第一个数字定义了响应的类别。</p><p>常见状态码类型：</p><blockquote><ul><li>1XX 提示信息——表示请求已被成功接收，继续处理。</li><li>2XX 成功——表示请求已被成功接收，理解，接受。</li><li>3XX 重定向——要完成请求必须进行更进一步的处理。</li><li>4XX 客户端错误——请求有语法错误或请求无法实现。</li><li>5XX 服务器端错误——服务器未能实现合法的请求。</li></ul></blockquote><ul><li><strong>响应头</strong></li></ul><p>响应头包含服务器对请求的应答信息，如 Content-Type 、 Server 、 Set-Cookie 等。</p><table><thead><tr><th style="text-align:center">响应头</th><th style="text-align:left">说 明</th></tr></thead><tbody><tr><td style="text-align:center">Allow</td><td style="text-align:left">服务器支持哪些请求方法（如 GET、POST 等）</td></tr><tr><td style="text-align:center">Content-Encoding</td><td style="text-align:left">文档的编码（Encode）方法。只有在解码之后才可以得到用 Content-Type 头指定的内容类型。利用 gzip 压缩文档能够显著地减少 HTML 文档的下载时间</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:left">表示内容长度。只有当浏览器使用持久 HTTP 连接时才需要这个数据</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:left">表示后面的文档属于什么 MIME 类型</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:left">当前的 GMT 时间</td></tr><tr><td style="text-align:center">Expires</td><td style="text-align:left">应该在什么时候认为文档已经过期，从而不再缓存它</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:left">文档的最后改动时间。可以通过 If-Modified-Since 请求头提供一个日期，该请求将被视为一个有条件的 GET 请求。只有改动时间迟于指定时间的文档才会返回，否则返回一个 304（Not Modified）状态。</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:left">也可用setDateHeader()方法来设置</td></tr><tr><td style="text-align:center">Location</td><td style="text-align:left">表示客户端应该当到哪里去提取文档，通常不是直接设置的</td></tr><tr><td style="text-align:center">Refresh</td><td style="text-align:left">表示浏览器应该在多少时间之后刷新文档，以秒计</td></tr><tr><td style="text-align:center">Server</td><td style="text-align:left">服务器的名字</td></tr><tr><td style="text-align:center">Set-Cookie</td><td style="text-align:left">设置和页面关联的 Cookie</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:left">客户应该在 Authorization 头中提供的授权信息。在包含 401（Unauthorized）状态行的应答中这个信息是必需的</td></tr></tbody></table><ul><li><strong>响应体</strong></li></ul><p>响应体是 HTTP 请求返回的内容，响应的正文数据都在响应体中。</p><h3 id="Go-语言中的-HTTP"><a class="header-anchor" href="#Go-语言中的-HTTP">☃</a>Go 语言中的 HTTP</h3><p>Go 语言中请求头和响应头使用 Header 类型表示，Header 类型是一个映射(map)类型，表示 HTTP 请求头中的多个键值对。其定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Header <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过请求对象的 Header 属性可以访问到请求头信息。Header 属性是映射结构，提供了 Get() 方法以获取 key 对应的第一个值。Get()  方法的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Header 结构体的其他常用方法的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span><span class="token function">Set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 设置头信息</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span><span class="token function">Add</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">//添加头信息</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Del</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">//删除头信息</span><span class="token keyword">func</span><span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token builtin">error</span>  <span class="token comment">//使用线模式 (in wire format) 写头信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请求体和响应体都由 Request 结构中的 Body 字段表示。 Body 字段是一个 <code>io.ReadCloser</code> 接口。<code>ReadCloser</code> 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ReadCloser <span class="token keyword">interface</span> <span class="token punctuation">{</span>ReaderCloser<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Body 字段是 <code>Reader</code> 接口和 <code>Closer</code> 接口的结<br>合。<code>Reader</code> 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过 Reader 接口可以看到，Read() 方法实现了 ReadCloser 接口。所以，可以通过 Body.Read() 方法来读取请求体信息接下来通过示例来加深对 Body.Read() 方法的理解。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">getBody</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token builtin">len</span> <span class="token operator">:=</span> r<span class="token punctuation">.</span>ConterntLengthbody <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/getBody"</span><span class="token punctuation">,</span> getBody<span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8082"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ResponseWriter 接口包含 WriteHeader() 、Header() 、Write() 三个方法来设置响应状态码。</p><ul><li><strong>WriteHeader()</strong> 方法</li></ul><p>WrteHeader() 方法支持传入一个整型数据来表示响应状态码，如果不调用该方法，则默认响应状态码是 200 。 WriteHeader() 方法的主要作用是在 API 接口中返回错误码。例如，可以自定义一个处理器方法 noAuth() ，并通过 w.WriteHeader() 方法返回一个 401 未认证状态码（注意：在运行时，w 代表的是对应的 response 对象实例，而不是接口）。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">noAuth</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token comment">//默认200</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"未授权，认证后才能访问该接口！"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/noAuth"</span><span class="token punctuation">,</span> noAuth<span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8086"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Header()</strong> 方法</li></ul><p>Header() 方法用于设置响应头。可以通过 Header().Set() 方法设置响应头。w.Header() 方法返回的是 Header 响应头对象，它和请求头共用一个结构体。因此在请求头中支持的方法这里都支持，比如可以通过 w.Header().Add() 方法新增响应头。<br>例如，如果要设置一个 301 重定向响应，则只需要通过 w.WriteHeader() 方法将响应状态码设置为 301 ，再通过 w.Header().Set() 方法将 “Location” 设置为一个可访问域名即可。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Redirect</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token comment">// 设置一个 301 重定向，重定向无需响应体。</span>w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Location"</span><span class="token punctuation">,</span> <span class="token string">"https://www.shirdon.com"</span><span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token number">301</span><span class="token punctuation">)</span><span class="token comment">//WriteHeader()调用后，无法设置响应头。</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/redirect"</span><span class="token punctuation">,</span> Redirect<span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8086"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示：w.Header.Set( )方法应在 w.WriteHeader() 方法之前被调用，因为一旦调用了 w.WriteHeader() 方法，就不能对响应头进行设置了。</p></blockquote><ul><li><strong>Wite()</strong> 方法</li></ul><p>Write() 方法用于将数据写入 HTTP 响应体中。如果在调用 Write() 方法时还不知道 Coment-Te 真型，则可以通过数据的前 512 个 byte 进行判断。用 Write()方法可以返回字符毫数据也可以返回 HTML 文档和 JSON 等常见的文本格式。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Welcome</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>  <span class="token punctuation">{</span>w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"你好～，欢迎一起学习《Go Web编程实战派从入门到精通》！"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/welcome"</span><span class="token punctuation">,</span> Welcome<span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8086"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>响应头中 Content-Type 根据传入数据自行判断。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Home</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>  <span class="token punctuation">{</span>html <span class="token operator">:=</span> <span class="token string">`&lt;html&gt;         &lt;head&gt;            &lt;title&gt;Write方法返回HTML文档&lt;/title&gt;        &lt;/head&gt;         &lt;body&gt;            &lt;h1&gt;你好，欢迎一起学习《Go Web编程实战派从入门到精通》        &lt;/body&gt;     &lt;/html&gt;`</span>w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> Home<span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8086"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"encoding/json"</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Greeting <span class="token keyword">struct</span> <span class="token punctuation">{</span>Message <span class="token builtin">string</span> <span class="token string">`json:"message"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Hello</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token comment">// 返回 JSON 格式数据</span>greeting <span class="token operator">:=</span> Greeting<span class="token punctuation">{</span><span class="token string">"欢迎一起学习《Go Web编程实战派从入门到精通》"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>message<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span>w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> Hello<span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8086"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Response"><a class="header-anchor" href="#Response">☃</a><strong>Response</strong></h3><p>Response 是 HTTP 请求的响应，包含返回给浏览器端的数据。</p><p>结构体定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Response <span class="token keyword">struct</span> <span class="token punctuation">{</span>Status <span class="token builtin">string</span> <span class="token comment">// e.g. "200OK"</span>StatusCode <span class="token builtin">int</span> <span class="token comment">// e.g. 200</span>Proto <span class="token builtin">string</span> <span class="token comment">// e.g. "HTTP/1.0"</span>ProtoMajor <span class="token builtin">int</span> <span class="token comment">// e.g. 1</span>ProtoMinor <span class="token builtin">int</span> e<span class="token punctuation">.</span>g<span class="token punctuation">.</span> <span class="token number">0</span>Header HeaderBody io<span class="token punctuation">.</span>ReadCloserContentLength <span class="token builtin">int64</span>TransferEncoding<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>Close <span class="token builtin">bool</span>Uncompressed <span class="token builtin">bool</span>Trailer HeaderRequest <span class="token operator">*</span>RequestTLS <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionState<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="Go-Web-服务器"><a class="header-anchor" href="#Go-Web-服务器">☃</a>Go Web 服务器</h1><hr><hr><h2 id="Go-Web-服务器工作流程"><a class="header-anchor" href="#Go-Web-服务器工作流程">☃</a>Go Web 服务器工作流程</h2><hr><p>Go Web 服务器请求和响应的流程如下：</p><ul><li><p>客户端发送请求</p></li><li><p>服务器端的多路复用器收到请求</p></li><li><p>多路复用器根据请求的URL找到注册的处理器，将请求交由处理器处理</p></li><li><p>处理器执行程序逻辑，如果必要，则与数据库进行交互，得到处理结果</p></li><li><p>处理密调用模板引擎将指定的模板和上一步得到的结果渲染成客户端可识别的数据格式（通常是 HTML 格式）</p></li><li><p>服务器端将数据通过 HTTP 响应返回给客户端</p></li><li><p>客户端拿到数据，执行对应的操作（如渲染出来呈现给用户）</p></li></ul><hr><p>简单的 Go Web 服务器</p><pre class="line-numbers language-none"><code class="language-none">package mainimport ("fmt""log""net/http")func action(w http.ResponseWriter, r *http.Request) {fmt.Fprintf(w, "Hello Go Web!")}func main() {http.HandleFunc("/hello", action)if err := http.ListenAndServe(":8081", nil); err != nil {log.Fatal(err)}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ResponseWriter"><a class="header-anchor" href="#ResponseWriter">☃</a><strong>ResponseWriter</strong></h3><p>Co 语言对接口的实现，不需要显式的声明，只要实现了被口定义的方法，就实现了相应的接口。<br><code>io.Wrter</code> 是一个接口类型。如果要使用 <code>io.Writer</code>  接口的 Write() 方法，则需要实现 Write([]byte) (n int, err error) 方法。</p><p>在 Go 语言中，客户端请求信息都被封装在 Request 对象中。但是发送给客户端的响应并不是 Response 对象，而是 ResponseWriter 接口。ResponseWriter 接口是处理器用来创建 HTTP 响应的接口的。ResponseWriter 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ResponseWriter <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token comment">// 用于设置或者获取所有响应头信息</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Header<span class="token comment">// 用于写入数据到响应体中</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// 用于设置响应状态码</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>statusCode <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，在底层支撑 ResponseWriter 接口的是 http.response 结构体。在调用处理器处理 HTTP 请求时，会调用 readRequest() 方法 readRequest() 方法会声明response结构体，并且其返回值是 response 指针这也是在处理器方法声明时，Reqyest 是指针类型，而 ResponseWriter 不是指针类型的原因。实际上，响应对象也是指针类型。<br>核心代码如下： readRequest()方法的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>w <span class="token operator">=</span> <span class="token operator">&amp;</span>response<span class="token punctuation">{</span>conn<span class="token punctuation">:</span>c<span class="token punctuation">,</span>cancelCtx<span class="token punctuation">:</span>cancelCtx<span class="token punctuation">,</span>req<span class="token punctuation">:</span>req<span class="token punctuation">,</span>reqBody<span class="token punctuation">:</span>req<span class="token punctuation">.</span>Body<span class="token punctuation">,</span>handlerHeader<span class="token punctuation">:</span><span class="token function">make</span><span class="token punctuation">(</span>Header<span class="token punctuation">)</span><span class="token punctuation">,</span>contentLength<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>closeNotifyCh<span class="token punctuation">:</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>wants10KeepAlive<span class="token punctuation">:</span>req<span class="token punctuation">.</span><span class="token function">wantsHttp10KeepAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>wantsClose<span class="token punctuation">:</span>req<span class="token punctuation">.</span><span class="token function">wantsClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">if</span> isH2Upgrade <span class="token punctuation">{</span>w<span class="token punctuation">.</span>closeAfterReply <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span>w<span class="token punctuation">.</span>cr<span class="token punctuation">.</span>res <span class="token operator">=</span> ww<span class="token punctuation">.</span>w <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">.</span>cw<span class="token punctuation">,</span> bufferBeforeChunkingSizw<span class="token punctuation">)</span><span class="token keyword">return</span> w<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>response 结构体的定义和 ResponseWriter 接口都位于 server.go 文件中。不过由于 response 结构体是私有的，对外不可见，所以只能通过 ResponseWriter 接口访问它。两者之间的关系是：ResponseWriter 是一个接口，而 response 结构体实现了。我们引用 ResponseWriter 接口，实际上引用的是 response 结构体的实例。</p><h3 id="Request"><a class="header-anchor" href="#Request">☃</a><strong>Request</strong></h3><p>Request 是 HTTP 请求，用于返回 HTTP 请求的报文，里面包含了浏览器端的相关信息。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">{</span>Method <span class="token builtin">string</span> <span class="token comment">//请求的方法</span>URL <span class="token operator">*</span>url<span class="token punctuation">.</span>URL <span class="token comment">//请求报文中的 URL 地址，是指针类型Proto string //形如："HTTP/1.0”</span>ProtoMajorint <span class="token comment">//1</span>ProtoMinorint <span class="token comment">//0</span>Header Header <span class="token comment">// 请求头字段</span>Bodyio<span class="token punctuation">.</span>ReadCloser <span class="token comment">// 请求体</span>GetBody <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>ContentLength <span class="token builtin">int64</span>TransferEncoding <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token comment">//</span>Close <span class="token builtin">bool</span>Host <span class="token builtin">string</span>请求报文中的一些参数，包括表单字段等Form url<span class="token punctuation">.</span>ValuesPostForm url<span class="token punctuation">.</span>ValuesMultipartForm <span class="token operator">*</span>multipart<span class="token punctuation">.</span>FormTrailer HeaderRemoteAddr <span class="token builtin">string</span>RequestURI <span class="token builtin">string</span>TLS <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionStateCancel <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Response <span class="token operator">*</span>Responsectx context<span class="token punctuation">.</span>Context<span class="token punctuation">}</span><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">{</span>Method <span class="token builtin">string</span>URL <span class="token operator">*</span>url<span class="token punctuation">.</span>URLProto <span class="token builtin">string</span>ProtoMajor <span class="token builtin">int</span>ProtoMinor <span class="token builtin">int</span>Header HeaderBody io<span class="token punctuation">.</span>ReadCloserGetBody <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>ContentLength <span class="token builtin">int64</span>TransferEncoding <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>Close <span class="token builtin">bool</span>Host <span class="token builtin">string</span>Form url<span class="token punctuation">.</span>ValuesPostForm url<span class="token punctuation">.</span>ValuesMultipartForm <span class="token operator">*</span>multipart<span class="token punctuation">.</span>FormTrailer HeaderRemoteAddr <span class="token builtin">string</span>RequestURI <span class="token builtin">string</span>TLS <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionStateCancel <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Response <span class="token operator">*</span>Responsectx context<span class="token punctuation">.</span>Context<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Reauest 结构体主要用于返回.话同的应，只有正确也解行真越数屏、才能内客户端返回响应。</p><p>下方是 Go 服务器端的代码，用于解析 Request 结构体中各成员（属性）。具体代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span>（<span class="token string">"fmt"</span><span class="token string">"log"</span><span class="token string">"net/http"</span><span class="token string">"strings"</span><span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token comment">//这些信息是输出到服务器端的打印信息</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Request解析"</span><span class="token punctuation">)</span><span class="token comment">//HTTP方法</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"method"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Method<span class="token punctuation">)</span><span class="token comment">//RequestURI是被客户端发送到服务器端的请求行中未修改的请求</span>URIfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"RequestURI:"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>RequestURI<span class="token punctuation">)</span><span class="token comment">//URL 类型，下方分别列出URL的各成员</span>fnt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL_path"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>fnt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL RawQuery"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>RawQuery<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL_Fragment"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Fragment<span class="token punctuation">)</span><span class="token comment">//协议版本</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"proto"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>Proto<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"protomajor"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>ProtoMajor<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"protominor"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ProtoMinor<span class="token punctuation">)</span><span class="token comment">//HTTP请求头</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>Header一<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> vv <span class="token operator">:=</span> <span class="token keyword">range</span> v <span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"header key:"</span><span class="token operator">+</span> k<span class="token operator">+</span><span class="token string">"value:"</span><span class="token operator">+</span> vv<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//判断是否为multipart方式</span>isMultipart<span class="token operator">:=</span> <span class="token boolean">false</span><span class="token keyword">for</span> <span class="token punctuation">,</span> v<span class="token operator">:=</span><span class="token keyword">range</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Content-Type"</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token string">"multipart/form-data"</span><span class="token punctuation">)</span> ！<span class="token operator">=</span><span class="token operator">-</span><span class="token function">1</span><span class="token punctuation">(</span>isMultipart <span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">(</span>解析 Form表单<span class="token keyword">if</span> isMultipart <span class="token operator">==</span> <span class="token boolean">true</span> r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"解析方式:ParseMultipartForm"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span> （r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"解析方式：ParseForm"</span><span class="token punctuation">)</span><span class="token comment">//HTTP Body 内容长度</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ContentLength"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ContentLength<span class="token punctuation">)</span><span class="token comment">//是否在回复请求后关闭连接</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Close"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Close<span class="token punctuation">)</span><span class="token comment">//HOST</span>fmt<span class="token punctuation">.</span>Prin host"<span class="token punctuation">,</span>r<span class="token punctuation">.</span>Host<span class="token punctuation">)</span><span class="token comment">//该请求的来源地班</span>fmt<span class="token punctuation">.</span><span class="token function">PrintIn</span><span class="token punctuation">(</span><span class="token string">"RemoteAddr"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>RemoteAddr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hello, let's go!"</span><span class="token punctuation">)</span> <span class="token comment">//这个是输出到客户端的</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span>request<span class="token punctuation">)</span>err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8081"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"ListenAndServe:"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"log"</span><span class="token string">"net/http"</span><span class="token string">"strings"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Request解析"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"method:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Method<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"RequestURI:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>RequestURI<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL.Path:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL.RawQuery:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>RawQuery<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL.Fragment:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Fragment<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Proto:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Proto<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ProtoMajor:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ProtoMajor<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ProtoMinor:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ProtoMinor<span class="token punctuation">)</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>Header <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> vv <span class="token operator">:=</span> <span class="token keyword">range</span> v <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"header key:"</span> <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token string">" value:"</span> <span class="token operator">+</span> vv<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>isMultipart <span class="token operator">:=</span> <span class="token boolean">false</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Content-Type"</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token string">"multipart/form-data"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>isMultipart <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> isMultipart <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token punctuation">{</span>r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"解析方式：ParseMultipartForm"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"解析方式：ParseForm"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ContentLength:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ContentLength<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Close:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Close<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Host:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Host<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"RemoteAddr:"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>RemoteAddr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hello, let's go!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8081"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"ListenAndServe:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多路复用器工作原理"><a class="header-anchor" href="#多路复用器工作原理">☃</a><strong>多路复用器工作原理</strong></h3><p>多路复用器用于转发请求到处理器,会在映射中找出被请求 URL 最为匹配的 URL 将请求重定向至相应的处理器，它然后调用与之相对应的处理器的 ServeHTTP 方法来处理请求。</p><p>DefaultServeMux 是 <code>net/http</code> 包中默认提供的一个多路复用器，其实质是 ServeMux 的一个实例，如果用户没有为 Server 对象指定处理器，则服务器默认使用 DefaultServeMux 作为 ServeMux 结构体的实例 ServeMux 也是一个处理器，可以在需要时对其实仪实施处理器串联。</p><p>默认的多路复用器 DefaultServeMux 其声明语句如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> DefaultServeMux <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultServeMux<span class="token keyword">var</span> defaultServeMux ServeMux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>HandleFunc() 函数用于为指定的 URL 注册一个处理器，HandleFunc() 处理器函数会在内部调用 DefaultServeMux 对象的对应方法，其内部实现如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//为指定 URL 注册处理器</span><span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWrite<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>DefaultServeMux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>DefaultServeMux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>handler <span class="token operator">:=</span> sh<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler<span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>handler <span class="token operator">=</span> DefaultServeMux<span class="token punctuation">}</span>handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的方法体可以看出，http.HandleFunc() 函数将处理器注册到多路复用器中。用默认多路复用器还可以指定多个处理器，其使用方法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">type</span> handle1 <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h1 <span class="token operator">*</span>serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hi, handle1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">type</span> handle2 <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h2 <span class="token operator">*</span>serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hi, handle2"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>handle1 <span class="token operator">:=</span> handle1<span class="token punctuation">{</span><span class="token punctuation">}</span>handle2 <span class="token operator">:=</span> handle2<span class="token punctuation">{</span><span class="token punctuation">}</span>server <span class="token operator">:=</span> http<span class="token punctuation">.</span>Server <span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> <span class="token string">"0.0.0.0:8085"</span><span class="token punctuation">,</span>Handler<span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span><span class="token punctuation">}</span>http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/handle1"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle1<span class="token punctuation">)</span>http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/handle2"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle2<span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，直接用 http.Handle() 函数来指定多个处理器。Handle() 函数的代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>DefaultServeMux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过代码可以看到，在 http.Handle() 函数中调用了 DefaultServeMux.Handle() 方法来处理清求服 器收到的每个请求都会调用对应多路复用器的 ServeHTTP() 方法。该方法的代码详情如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>handler <span class="token operator">:=</span> sh<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler<span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>handler <span class="token operator">=</span> DefaultServeMux<span class="token punctuation">}</span>handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 ServeMux 对象的 ServeHTTP() 方法中，会根据 URL 查找注册的处理器，然后将请求交由它处理。默认的多路复用器在生产环境中不建议使用，因为 DefaultServeMux 是一个全局变量，所有代码（包括第三方代码）都可以修改它。有些第三方代码会在  DefaultServeMux 中注册一些处理器，这可能与注册的处理器冲突。比较推荐的做法是自定义多路复用器。</p><p>自定义多路复用器也比较简单，直接调用  http.NewServeMux() 函数即可。然后，在新创建的多路复用器上注册处理器；</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewSeryeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"log"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">hi</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hi, web"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>server <span class="token operator">:=</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Server <span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> <span class="token string">"8081"</span><span class="token punctuation">,</span>Handler<span class="token punctuation">:</span> mux<span class="token punctuation">,</span>ReadTimeot<span class="token punctuation">:</span> <span class="token number">5</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span>WriteTimeot<span class="token punctuation">:</span> <span class="token number">5</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面代码中，创建了一个读超时和写超时均为5s的服务器。</p><p>简单总结一下<br>ServerMux 实现了 http.Handler 接口的 ServeHTTP(ResponseWriter.*Request) 方法。在创建  Server 时，如果设置 Handler 为空，则使用 DefaultServeMux 作为默认的处理器，而 DefaultServeMux 是 ServerMux 的一个全局变量。</p><h3 id="ServerMux"><a class="header-anchor" href="#ServerMux">☃</a><strong>ServerMux</strong></h3><p>conn.server 内部调用了 <code>net/http</code> 包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。</p><p>DefualtSeveMux 也提供了 DefaultServeMux handle 和 DefaulterveMux handleFunc这两个函数。可用它们把 http Handle 和 http.andleFunc 的 patern和 Handler 函数绑定到 ServerMux 上。DefaultServeMux 是 ServerMux 的实例对象，下面来看一下 ServerMux 的结构体定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span><span class="token punctuation">(</span>mu sync<span class="token punctuation">.</span>RWMutex<span class="token comment">// 读写锁，由于请求涉及到并发处理</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry<span class="token comment">//路由 map ， pattern-&gt;HandleFunc ，路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span>hosts <span class="token builtin">bool</span><span class="token comment">// 是否包含 hosts</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span><span class="token punctuation">(</span>explicit <span class="token builtin">bool</span><span class="token comment">//是否精确匹配，http包内都使用ture</span>h Handler <span class="token comment">// 路由对应的Handler</span>pattern <span class="token builtin">string</span><span class="token comment">// 路由</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的路由和 handler 的绑定最终都存储到这里。因为 <code>net/http</code> 包内仅支持精确匹配，所以使用标准的 <code>net/http</code> 包不能直接配置带参数的路由，只能配置参数前面的路径，然后在 handler 内部再处理。也可以借助第三方包，比如 httprouter 。</p><h3 id="ServeMux-的-URL-路由匹配"><a class="header-anchor" href="#ServeMux-的-URL-路由匹配">☃</a><strong>ServeMux 的 URL 路由匹配</strong></h3><p>在实际应用中，一个 Web 服务器往往有很多的 URL 绑定，不同的URL对应不同的处理器。服务器是决定使用哪个处理器过程：</p><ul><li>假如现在绑定了 3 个 URL，分别是 / 、/hi 和 /hi/web</li><li>如果请求的 URL为 /，则调用 / 对应的处理器</li><li>如果请求的 URL 为 /hi ，则调用 /hi 对应的处理器</li><li>如果请求的 URL 为 /hi/web ，则调用 /hi/web 对应的处理器。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"log"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">indexHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"欢迎来到Go Web首页！处理器为：indexHandler！"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">hiHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"欢迎来到Go Web首页！处理器为：hiHandler！"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">webHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"欢迎来到Go Web首页！处理器为：webHandler！"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> indexHandler<span class="token punctuation">)</span><span class="token comment">// "/", "/hi/"，"/hi/web/"</span>mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hi"</span><span class="token punctuation">,</span> hiHandler<span class="token punctuation">)</span><span class="token comment">// "/hi"</span>mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hi/web"</span><span class="token punctuation">,</span> webHandler<span class="token punctuation">)</span><span class="token comment">// "/hi/web"</span>server <span class="token operator">:=</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Server <span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> <span class="token string">":8083"</span><span class="token punctuation">,</span>Handler<span class="token punctuation">:</span> mux<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="处理器"><a class="header-anchor" href="#处理器">☃</a><strong>处理器</strong></h3><p>Web 服务器在收到请求后，会根据其 URL 将请求交给相应的多路复用器，多路复用器将请求转发给处理器处理。处理器是实现了 Handler 接口的结构。Handler 接口被定义在 <code>net/http</code> 包中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token keyword">func</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"log"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">type</span> WelcomeHandler <span class="token keyword">struct</span> <span class="token punctuation">{</span>Language <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h WelcomeHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span>Language<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewServeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/cn"</span><span class="token punctuation">,</span> WelcomeHandler<span class="token punctuation">{</span>Language<span class="token punctuation">:</span> <span class="token string">"欢迎一起来学Go Web!"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/en"</span><span class="token punctuation">,</span> WelcomeHandler<span class="token punctuation">{</span>Language<span class="token punctuation">:</span> <span class="token string">"Welcome you, let's learn Go Web!"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>server <span class="token operator">:=</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Server <span class="token punctuation">{</span>Addr<span class="token punctuation">:</span>   <span class="token string">":8082"</span><span class="token punctuation">,</span>Handler<span class="token punctuation">:</span> mux<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，Handler 接口中只有一个 ServeHTTP() 处理器方法。任何实现了 Handle 接口的对象，都可以被注册到多路复用器。</p><h3 id="处理器函数"><a class="header-anchor" href="#处理器函数">☃</a><strong>处理器函数</strong></h3><p>下面以默认的处理器函数 HandleFunc() 为例介绍处理器的使用方法。</p><ul><li>注册一个处理器函数</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> func_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个处理器函数的第 1 个参数表示匹配的路由地址 第 2 个参数表示一个名为 func_name 的方法，用于处理具体业务逻辑。例如，注册一个处理器函数，并将处理器的路由匹配到 hi 函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>定义一个名为 hi 的函数，用来打印一个字符串到浏览器：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hi</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hi Web!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Server"><a class="header-anchor" href="#Server">☃</a><strong>Server</strong></h3><p>在配置好路由、处理函数以后，接下来就要启动服务，可使用如下代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>"<span class="token punctuation">:</span><span class="token number">8080</span>°<span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数是监听的端口，以字符串的形式传递；第二个参数是 handler ，传入的是il该语句执行完毕后就开始监听 8080 端口，来看一下该函数的源码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">LiatenAndserve</span><span class="token punctuation">(</span>addrstringrhandler Handler<span class="token punctuation">)</span><span class="token builtin">error</span><span class="token punctuation">[</span>server te <span class="token function">aServer</span><span class="token punctuation">(</span>Addr<span class="token punctuation">:</span>addr<span class="token punctuation">:</span>Handler<span class="token punctuation">:</span> handler<span class="token punctuation">)</span><span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出，该方法首先要做的就是创建  Server 的实例，并且调用其 ListenAndServe方。Server的结构体：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1.</span> <span class="token keyword">type</span> Server atruct监听的地址和婚口Addr <span class="token builtin">string</span><span class="token number">3.</span> <span class="token number">2.</span> Bandler Bandler <span class="token comment">// handlerto invoke, http.DefaultServeMuxif nil</span>TLSContig<span class="token operator">*</span>tls<span class="token punctuation">.</span>Config <span class="token operator">/</span><span class="token number">1</span> 读超时时间<span class="token number">5.</span> ieadTineouttime<span class="token punctuation">.</span>Durationtime<span class="token punctuation">.</span>Doration <span class="token comment">// 读关文件超时时间</span><span class="token number">6.</span> ReadieaderTineout<span class="token number">7.</span> writeTimeouttime<span class="token punctuation">.</span>Duration <span class="token comment">//写超时时间</span><span class="token number">8.</span> IdleTimoout time<span class="token punctuation">.</span>Duration<span class="token number">9.</span> HaxlleaderBytesint<span class="token number">10.</span> TLSNextProtonap<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token operator">*</span>tls<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> Handler<span class="token punctuation">)</span><span class="token number">12.</span> ConnState <span class="token keyword">func</span> <span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> ConnState<span class="token punctuation">)</span><span class="token number">12.</span> ErrorLog ·log<span class="token punctuation">.</span>Logger<span class="token number">13.</span><span class="token number">14.</span> BaseContextfunc <span class="token punctuation">(</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> context<span class="token punctuation">.</span>ContextConnContext <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context<span class="token number">25.</span><span class="token number">16.</span> disableKeepAlivesint32 accessed atomically<span class="token punctuation">.</span><span class="token number">17.</span> inShut<span class="token punctuation">.</span>dowm <span class="token builtin">int</span> <span class="token number">32</span> accessedatomically <span class="token punctuation">(</span>non<span class="token operator">-</span>zero means we're in<span class="token number">18.</span><span class="token number">19.</span> nextProtoonce sync<span class="token punctuation">.</span>Once <span class="token comment">// guards setupHTTP2</span>init<span class="token number">11</span> http2<span class="token punctuation">.</span>ConfigureServerShutdown<span class="token punctuation">)</span><span class="token number">20.</span> nextProtoErr erTor result of <span class="token keyword">if</span> used<span class="token number">21.</span> mu sync<span class="token punctuation">,</span>Mutex<span class="token number">22.</span><span class="token number">23.</span> 1isteners <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token operator">*</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">24.</span> activeConndoneChan <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token operator">*</span>conn<span class="token punctuation">)</span><span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">25.</span> onShutdownchan<span class="token punctuation">(</span><span class="token function">lfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">26.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Server 的三个方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>srv<span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">ListenAndServeTLS</span><span class="token punctuation">(</span>certFile<span class="token punctuation">,</span> keyFile <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Serve 方法</p><ul><li>ListenAndServe 方法的作用是开启 http Server服务。</li><li>ListenAndServeTLS 方法的作用是开启 https Server 服务。</li></ul><p>ResponseWriter ：生成 Response的接口。</p><p>ServerMux ：路由处理函数，这个刚刚介绍过。</p><p>在 Serve 方法执行完成后，就执行 Conn （连接）的 Serve 方法，然后再通过 Conn 的readRequest 方法获取 Response。从逻辑上来说，c.serve方法就是完成这个功能的，此处需关注以下三个接口。</p><ul><li><strong>ResponseWriter</strong> 接口</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ResponseWriter <span class="token keyword">interface</span><span class="token comment">// Beader 方法返回 Response 返回的 Header 供读写</span>Header <span class="token punctuation">(</span><span class="token punctuation">)</span> Header<span class="token comment">// Write 方法写 Response 的 Body</span><span class="token function">Write</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// WriteHeader 方法根据 HTTP 状态码来写 Response 的 Header</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该接口的主要作用是供 Handler 函数调用，用来生成要返回的 Response 。</p></blockquote><ul><li><strong>Flusher</strong> 接口</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Flusher <span class="token keyword">interface</span> t<span class="token comment">//刷新缓存区</span>Cotter <span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>该接口的主要作用是供 Handler 调用，将写缓存中的数据刷新到客户端。</p></blockquote><ul><li><strong>Hijacker</strong> 接口</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Hijacker <span class="token keyword">interface</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> Hijacker <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> <span class="token operator">*</span>bufio<span class="token punctuation">.</span>ReadWriter<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>该接口的主要作用是供Handler调用，用以关闭连接。</p></blockquote><p>以上是 Handler 在执行过程中最常用、最重要的三个接口，正是这三个接口使 Handler 可以在处理完逻辑后把结果写回客户端。</p><p>通过对 Server 的介绍，如何在接受请求后调用 Handler 并且生成 response 。</p><p>response 生成以后数据是如何写到客户端的呢？接下来我们开始了解response。</p><h3 id="response"><a class="header-anchor" href="#response">☃</a><strong>response</strong></h3><p>下面的方法用于把数据写给客户端：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">serverHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Server<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>w<span class="token punctuation">.</span>req<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该语句最终触发了路由绑定，w 是 response的实例对象(此处的 w是 ResponseWriter 接口)，response 实现了 ResponseWriter、Flusher、Hijacker接口。</p><p>response 结构体的定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> response <span class="token keyword">struct</span><span class="token punctuation">{</span>conn <span class="token operator">*</span>conn <span class="token comment">//保存此次HTTP连接的信息</span><span class="token comment">//对应请求信息</span><span class="token operator">*</span>Request <span class="token number">2.</span> <span class="token number">3.</span> regchunking <span class="token builtin">bool</span> <span class="token comment">//是否使用chunk</span> wroteHeaderbool <span class="token comment">// header是否已经执行过写操作</span><span class="token number">9.</span> wroteContinuebool <span class="token comment">//100 Continue response was written</span><span class="token number">10.</span> header Header <span class="token operator">/</span> <span class="token operator">/</span> 返回的 HTTP的Header<span class="token number">11.</span> written <span class="token builtin">int64</span> <span class="token comment">// Body的字节数</span><span class="token number">12.</span> contentLength <span class="token builtin">int64</span> <span class="token comment">// Content 长度</span>HTTP状态<span class="token number">10.</span>status<span class="token comment">//</span><span class="token number">13.</span> needSniffboolint<span class="token number">1</span><span class="token operator">/</span>是否开启sniff。若不设置Content<span class="token operator">-</span>Type，开启sniff能自动确定Content<span class="token operator">-</span>Type <span class="token operator">/</span><span class="token number">1</span> 是否保持长链接。若request有keep<span class="token operator">-</span>alive，该字<span class="token number">14.</span> closeAfterReplybool段就设置为<span class="token boolean">false</span>。 是否requestBody太大。当requestBody太大时，<span class="token number">15.</span> requestBodyLimitHitbool <span class="token comment">//</span>response 返回 <span class="token number">411</span><span class="token number">14.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器端需要返回给客户端的所有信息都包含在 response 中。</p><p>response 的主要方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Header<span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>code <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">Write</span><span class="token punctuation">(</span>data <span class="token punctuation">(</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">WriteString</span><span class="token punctuation">(</span>data <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// either dataB or dataS is non-zero.</span><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">write</span><span class="token punctuation">(</span>lenDataint<span class="token punctuation">,</span> dataB <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> dataS <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">finishRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Hijack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rwcnet<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> buf <span class="token operator">*</span>bufio<span class="token punctuation">.</span>ReadWriter<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，response 实现了ResponseWriter、Flusher、Hijacker三个接口，有了这三个接口，response 就可以把处理结果写回客户端。</p><h3 id="ServeHTTP-w-w-req"><a class="header-anchor" href="#ServeHTTP-w-w-req">☃</a><strong>ServeHTTP(w , w.req)</strong></h3><p>前面介绍了如何通过 response把数据写回客户端，不过 Handler 如何生成 response ，来看 Handler 接口：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span><span class="token punctuation">(</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token comment">//具体的逻辑函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在实现Handler接口的时候，就意味着已经有处理请求逻辑的函数了。serverHandle 通过 ServeHTTP 来选择触发 HandleFunc ，此处有一个判断，如果有自定义的 Handler 函数就调用自定义的处理器，如果是 nil 则使用默认的 DefaultServeMux 。<br>DefaultServeMux.ServeHttp的执行流程如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">i<span class="token punctuation">.</span> h<span class="token punctuation">,</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>ii<span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对这些内容的理解，此处再从执行流程上梳理一下，整体流程如下。</p><p>第一步：调用 http.HandleFunc 注册路由和对应处理函数。</p><p>第二步：先后调用 DefaultServeMux 的 HandleFunc 和 Handle ，并且向 handler(也就是 map[string]muxEntry) 中注册路由和对象的函数<br>。<br>第三步：实例化 Server，并调用 ListenAndServe 。</p><p>第四步：调用 net.Listen(“tcp”，addr)，等待请求，每一个请求创建一个 Conn，并且启动一个 goroutine 处理请求。</p><p>第五步：通过 readRequest 方法读取请求内容，或者说 response 的取值过程。</p><p>第六步：进入 serveHandler.ServeHTTP ， ServeHTTP 方法内会判断有没有自定义的 handler ，如果没有则使用默认的 DefaultServeMux。</p><p>第七步：调用 handler (或DefaultServeMux)的 ServeHTTP 方法。</p><p>第八步：通过 request 选择匹配的 handler ，遍历 muxEntry ，寻找满足这个 Request 的路由。如果找到满足条件的路由，调用对象 handler 的 ServeHTTP ；如果没有找到满足条件的路由，调用 NotFoundHandler 的 ServeHTTP 。</p><p><code>net/http</code> 包提供了以函数的方式注册处理器，即用HandleFunc() 函数来注册处理器，如果一个函数实现了匿多函数 func(w http.ResponseWriter,r *http.Request) ，则这个函数被为为“处理器函数”。 HandleFunc() 函数内部调用了 ServeMux 对象的 Handlefunc() 方法。ServeMux 对象的 HandleFunc() 方法具体代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: nil handler"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续查看内部代码可以发现 HandlerFunc( 函数最终也实现了 Handler 接口的 ServeHTTP() 方法。其实现代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Handler-的定义"><a class="header-anchor" href="#Handler-的定义">☃</a><strong>Handler</strong> 的定义</h3><p>Handler 是接收请求后逻辑处理和生成返回信息的逻辑。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>            <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>  <span class="token comment">// 路由实现器</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>调用了 HandlerFunc(f)，类似强制类型转换 f 成为 HandlerFunc 类型，这样 f 就拥有了 ServHTTP 方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>        <span class="token comment">// ServeHTTP calls f(w, r).</span>        <span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>路由器接收到请求之后调用 mux.handler®.ServeHTTP(w, r) ，也就是调用对应路由的 handler 的 ServerHTTP 接口</p><p>那么mux.handler®怎么处理的呢？</p><p>根据用户请求的 URL 和路由器里面存储的 map 去匹配的，当匹配到之后返回存储的 handler ，调用这个 handler 的 ServHTTP 接口就可以执行到相应的函数了。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> Handler <span class="token punctuation">{</span>            mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">// Host-specific pattern takes precedence over generic ones</span>            h <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Host <span class="token operator">+</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>            <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                h <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                h <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> h        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 语言其实支持外部实现的路由器 ListenAndServe 的第二个参数就是用以配置外部路由器的，它是一个 Handler 接口，即外部路由器只要实现了 Handler 接口就可以，我们可以在自己实现的路由器的ServHTTP 里面实现自定义路由功能。</p><ol><li>Handler：处理器接口。定义在 <code>net/http</code> 包中，实现了 Handler 接口的对象，可以生到多路复用器中。</li><li>Handle() ：注册处理器过程中的调用函数。</li><li>HandleFunc() ：处理器函数</li><li>HandlerFunc ：底层为 func (w  ResponseWriter , r *Request) 匿名函数，实现了 Handler 处理器接口。它用来连接处理器函数与处理器。</li></ol><p>简而言之 HandlerFunc() 是一个处理器函数，其内部通过对 ServeMux 中一系列方法的调用最终在底层实现了 Handler 处理器接口的 SepveHTTP) 方法，从而实现处理器的功能。</p><hr><h2 id="Go-语言中-net-http-包运行机制"><a class="header-anchor" href="#Go-语言中-net-http-包运行机制">☃</a>Go 语言中 net/http 包运行机制</h2><hr><ul><li><p>创建 Listen Socket，监听指定的端口，等待客户端请求</p></li><li><p>Listen Socket 接受客户端的请求, 得到 Client Socket ，接下来通过 Client Socket 与客户端通信</p></li><li><p>处理客户端的请求，首先从 Client Socket 读取HTTP请求的协议头，如果是 POST 方法，还可能要读取客户端提交的数据，然后交给相应的 handler 处理请求，handler 处理完毕准备好客户端需要的数据，通过 Client Socket 写给客户端。</p></li></ul><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_133058.jpg" alt="net/http 包的运行示意图"></p><hr><p>整个的过程中，只要了解清楚下面三个问题就知道 Go 语言是如何让 Web 运作起来：</p><ul><li><p>如何监听端口？</p></li><li><p>如何接收客户端请求？</p></li><li><p>如何分配handler？</p></li></ul><p>下面通过一个具体的实例来说明：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>            <span class="token string">"fmt"</span>            <span class="token string">"net/http"</span>        <span class="token punctuation">)</span>        <span class="token keyword">type</span> MyMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>MyMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path <span class="token operator">==</span> <span class="token string">"/"</span> <span class="token punctuation">{</span>                <span class="token function">sayhelloName</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token punctuation">}</span>            http<span class="token punctuation">.</span><span class="token function">NotFound</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">func</span> <span class="token function">sayhelloName</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello myroute!"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            mux <span class="token operator">:=</span> <span class="token operator">&amp;</span>MyMux<span class="token punctuation">{</span><span class="token punctuation">}</span>            http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":9090"</span><span class="token punctuation">,</span> mux<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230105_132916.jpg" alt="net/http 包运行流程图"></p><blockquote><p>Go 语言是通过函数 ListenAndServe 来监听端口，这个底层是这样处理的：初始化一个 server 对象，调用 net. Listen(“tcp”, addr) ，底层用 TCP 协议搭建了一个服务，然后监控设置的端口。</p></blockquote><blockquote><p>执行监控端口之后，调用了  srv.Serve(net.Listener) 函数来处理接收客户端的请求信息。这个函数里面起了一个  for{} ，首先通过 Listener 接收请求，其次创建一个 Conn ，最后单独开了一个 goroutine ，把这个请求的数据当做参数传递给这个 conn 去服务 go c.serve() 。</p></blockquote><h3 id="Conn-中的协程"><a class="header-anchor" href="#Conn-中的协程">☃</a><strong>Conn</strong> 中的协程</h3><p>Go 语言为了实现高并发和高性能, 使用 Goroutines 处理 Conn 的读写事件，这样每个请求都能保持独立，相互不会阻塞，以高效响应网络事件。</p><p>Go 语言在等待客户端请求时写下如下代码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">c<span class="token punctuation">,</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        <span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端的每次请求都会创建一个 Conn，这个Conn 里面保存了该次请求的信息，然后再传递到对应的 handler ，该 handler 中便可以读取到相应的 header 信息，以保证了每个请求的独立性。</p><p>下面通过源码来看  Go 语言对于 HTTP 请求的处理过程。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"> <span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token punctuation">{</span><span class="token keyword">defer</span> <span class="token number">1.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">3.</span> <span class="token keyword">var</span> tempDelay time<span class="token punctuation">.</span>Duration<span class="token comment">// how long to sleep on accept failure</span><span class="token number">4.</span> <span class="token keyword">for</span><span class="token punctuation">{</span><span class="token number">5.</span> rw<span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token number">1.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">6.</span> <span class="token keyword">if</span> e ！<span class="token operator">=</span><span class="token boolean">nil</span> <span class="token punctuation">(</span><span class="token number">7.</span> <span class="token keyword">if</span> ne<span class="token punctuation">,</span> ok <span class="token operator">:=</span> e<span class="token punctuation">.</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> ne<span class="token punctuation">.</span><span class="token function">Temporary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">8.</span><span class="token keyword">if</span> tempDelay<span class="token operator">=</span><span class="token number">5</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token number">10.</span> tempDelay<span class="token operator">*=</span><span class="token number">2</span><span class="token number">11.</span> <span class="token punctuation">)</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">;</span> tempDelay <span class="token operator">&gt;</span> max：<span class="token operator">=</span><span class="token number">1</span><span class="token number">12.</span> <span class="token number">13.</span> <span class="token keyword">if</span> max tempDelay <span class="token operator">=</span> max 【<span class="token number">14.</span> <span class="token punctuation">)</span><span class="token number">15.</span> log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"http: Accept error: 8v; retrying in Bv"</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> tempDelay<span class="token punctuation">)</span><span class="token number">16.</span> time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>tempDelay<span class="token punctuation">)</span><span class="token number">17.</span> <span class="token keyword">continue</span><span class="token number">18.</span><span class="token number">19.</span> <span class="token keyword">return</span> e<span class="token number">21.</span> <span class="token number">20.</span> tempDelay <span class="token operator">=</span><span class="token number">0</span><span class="token number">22.</span><span class="token number">23.</span> c<span class="token punctuation">,</span> err：<span class="token operator">=</span>srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">(</span><span class="token number">24.</span><span class="token keyword">continue</span><span class="token number">25.</span><span class="token number">26.</span><span class="token number">27.</span> <span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">28.</span> <span class="token punctuation">}</span><span class="token number">29.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>Server 的 Serve(L net.Listener) 方法监听和处理 HTTP 请求</p></li><li><p>从第4行开始，函数中使用了一个 for 循环，第5行通过参数 Listener 的 Accept 接收请求</p></li><li><p>在第23行基于接收的信息新建一个Conn ，最后第27行启动一个 goroutine 来单独为一个 Conn 服务，不影响其他的 Conn</p></li></ul><blockquote><p>conn 首先会解析 request:c.readRequest() ，然后获取相应的 handler:handler := c.server.Handler ，也就是在调用函数 ListenAndServe 时候的第二个参数，前面例子传递的是 nil，默认获取 handler =  DefaultServeMux ，这个变量是一个路由器，它用来匹配 URL 跳转到其相应的 handle 函数。调用 http.HandleFunc(“/”, sayhelloName) 注册请求 “”/” 的路由规则，当请求 URL 为 “/”，路由就会转到函数 sayhelloName ，DefaultServeMux 会调用 ServeHTTP 方法，这个方法内部其实是调用 sayhelloName 本身，最后通过写入 response 的信息反馈到客户端。</p></blockquote><hr><ol><li>首先调用 Http.HandleFunc ，按顺序做如下操作：</li></ol><ul><li>调用了 DefaultServerMux 的 HandleFunc</li><li>调用了 DefaultServerMux 的 Handle</li><li>向 DefaultServeMux 的map[string]muxEntry 中增加对应的handler和路由规则</li></ul><ol start="2"><li>调用 http.ListenAndServe(“:9090”, nil) ，按顺序做如下操作：</li></ol><ul><li>实例化 Server</li><li>调用 Server 的ListenAndServe()</li><li>调用 net.Listen(“tcp”, addr)监听端口</li><li>启动一个 for 循环，在循环体中 Accept 请求</li><li>对每个请求实例化一个 Conn ，并且开启一个 goroutine 为这个请求进行服务 go  c.serve()</li></ul><ol start="3"><li><p>读取每个请求的内容 w, err := c.readRequest() 判断 handler 是否为空，如果没有设置 handler（此例子没有设置handler）， handler 就默认为DefaultServeMux。调用 handler 的 ServeHttp，在此例中，进入到 DefaultServerMux.ServeHttp 根据 request 选择 handler ，并且进入到这个 handler 的 ServeHTTP， mux.handler®.ServeHTTP(w, r)</p></li><li><p>选择 handler ：</p></li></ol><ul><li>判断是否有路由能满足这个 request（循环遍历 ServerMux 的 muxEntry）</li><li>如果有路由满足，调用这个路由 handler 的 ServeHttp</li><li>如果没有路由满足，调用 NotFoundHandler 的 ServeHttp</li></ul><p>至此，三个问题已经全部解答了对于 Go 语言如何让 Web 跑起来。</p><p>以上就是 <code>net/http</code> 包的核心源码按照功能整理如下：</p><p>(1)路由注册对应的源码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span>HandlerFunc<span class="token punctuation">:</span><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token keyword">func</span><span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> ServeHTTP <span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token keyword">func</span> HandleFunc <span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">func</span><span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span>accern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> http<span class="token punctuation">.</span>Handle<span class="token punctuation">:</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)接口监听相关源码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span><span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(3)接收客户端请求<br>Server的Serve方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Server 的 newConn 方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">newConn</span><span class="token punctuation">(</span>rwc net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> conn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(4)分配Handler</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fune <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span>serve <span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">readRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req Request<span class="token punctuation">)</span>DefaultServeMux<span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span><span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span>Handler接口的定义：<span class="token keyword">type</span> Handler <span class="token keyword">interface</span>ServeMux<span class="token punctuation">.</span>ServeHTTP<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span><span class="token function">ServelITTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span>mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span><span class="token function">Handler</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> handler <span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote></blockquote><h3 id="Handler"><a class="header-anchor" href="#Handler">☃</a><strong>Handler</strong></h3><p>Handler 是接收请求后逻辑处理和生成返回信息的逻辑。<br><code>net/http</code> 包的 Handle 和 HandleFunc 这两个函数的作用。这两个函数都是接收两个参数：第一个参数都是 pattern （请求路径），因为其效果都是给路径绑定处理函数，所以两个函数的作用是一样的；对于第二个参数，一个是 Handler 接口类型，也就是说只要实现了该接口的函数都可以作为第二个参数传人；另一个则是以函数类型作为参数，只要传入的函数以 func(w http.ResponseWriter , r *http.Request)形式声明就可以。因为 ServeHttp 的声明满足 HandleFunc 第二个参数的要求，所以上面代码中第 6 行可以改为：</p><p>虽然上面的两个函数在使用的时候有些区别，但是对于 Go 语言的底层实现来说并无二.，都是交给 DefaultServeMux 来完成处理函数和路由的绑定。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Go Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建个人博客和 Matery 主题配置优化</title>
      <link href="/posts/45644.html"/>
      <url>/posts/45644.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Hexo-的安装"><a class="header-anchor" href="#Hexo-的安装">☃</a>Hexo 的安装</h1><hr><p><a href="https://hexo.io/themes/">Hexo</a> 是一款基于 Node.js 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 GitHub 、Gitee 上，是搭建博客的首选框架。</p><hr><h2 id="安装-Git"><a class="header-anchor" href="#安装-Git">☃</a>安装 Git</h2><hr><p>Git 是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span> <span class="token parameter variable">-y</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-Node-js"><a class="header-anchor" href="#安装-Node-js">☃</a>安装 Node.js</h2><hr><p>Hexo 是基于 Node.js 编写的，所以需要安装一下 Node.js 和 npm 工具，Node.js 默认包含 npm 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> nodejs <span class="token function">npm</span> <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完后，输入如下命令，检查是否安装成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>升级 npm 到最新版本，更换 npm 源为淘宝源。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> <span class="token function">npm</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="升级-Node-js-版本"><a class="header-anchor" href="#升级-Node-js-版本">☃</a>升级 Node.js 版本</h2><hr><ul><li>清除 npm 缓存。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> cache clean <span class="token parameter variable">-f</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装 Node.js 版本管理工具 n 。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> n <span class="token parameter variable">-g</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看 Node.js 所有版本。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> view <span class="token function">node</span> versions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>升级 Node.js 版本。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 升级到指定的版本：n 版本号</span>n <span class="token number">16.0</span>.0<span class="token comment"># 升级到最新的稳定版本</span>n stable<span class="token comment"># 升级到最新版本，不推荐</span>n latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 <code>node -v</code> 查看 Node.js 版本，如果版本号改变为想要的则升级成功。如果版本号没变，可以重启机器或者尝试以下方法：</p><ol><li>查看安装 Node.js 的位置。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> <span class="token function">node</span>  /usr/local/n/versions/node/16.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>配置环境变量，进入该位置。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/n/versions/node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>编辑 <code>/etc/profile</code> ，将 Node.js 安装的路径，添加到文件末尾。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">NODE_HOME</span><span class="token operator">=</span>/usr/local/n/versions/node/16.0.0<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">$NODE_HOME</span>/bin:<span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>保存文件，再刷新 <code>/etc/profile</code> 。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-Hexo"><a class="header-anchor" href="#安装-Hexo">☃</a>安装 Hexo</h2><hr><p>前面 Git 和 Node.js 安装好后，就可以正式进行安装 Hexo 。</p><ol><li>安装 Hexo 。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>查看版本信息 。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="初始化-Hexo"><a class="header-anchor" href="#初始化-Hexo">☃</a>初始化 Hexo</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init filename（文件名随意定义）<span class="token builtin class-name">cd</span> filename //进入这个文件夹<span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><ul><li>hexo init</li></ul><blockquote><p>说明：自动在文件夹（filename）中创建项目所需的文件。</p></blockquote><ul><li>cd filename</li></ul><blockquote><p>说明：将操作位置转移到将要存放项目的文件夹目录。</p></blockquote><ul><li>npm install</li></ul><blockquote><p>说明：安装依赖包。</p></blockquote><p>上述步骤操作完成后，指定 Hexo 根目录下有如下文件：</p><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230110_111336.png" alt="Hexo 目录文件"></p><ul><li><code>_config.yml</code> ：站点的配置文件，需要备份。</li><li><code>themes</code> ：主题文件夹，需要备份。</li><li><code>source</code> ：博客文章的 .md 文件，需要备份。</li><li><code>scaffolds</code> ：文章的模板，需要备份。</li><li><code>package.json</code> ：安装包的名称，需要备份。</li><li><code>.gitignore</code> ：限定在 push 时哪些文件可以忽略，需要备份 .git ：主题和站点都有，标志这是一个 git 项目，不需要备份。</li><li><code>node_modules</code> ：是安装包的目录，在执行 npm install 的时候会重新生成，不需要备份。</li><li><code>public</code> ：是 hexo g 生成的静态网页，不需要备份。</li><li><code>deploy_git</code> ：同上，hexo g 也会生成，不需要备份。</li><li><code>db.json</code> ：文件，不需要备份。</li></ul><hr><h2 id="启动-Hexo-服务"><a class="header-anchor" href="#启动-Hexo-服务">☃</a>启动 Hexo 服务</h2><hr><p>正确安装完成后便按照下面操作启动 Hexo 博客。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate <span class="token comment"># 生成静态页面至 public 目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server <span class="token comment"># 开启预览访问端口（默认端口 4000 ，ctrl + c 关闭 server ）</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tao7app.files.wordpress.com/2023/01/screenshot_2023_0110_211105.png" alt="启动 Hexo 服务页面"></p><p>打开浏览器输入对应的网址 <strong><a href="http://localhost:4000">http://localhost:4000</a></strong> ，就可以看到生成的博客。</p><p><img src="https://tao7app.files.wordpress.com/2023/01/img_20230108_005221.png" alt="Hexo 博客首页"></p><hr><h1 id="Hexo-部署到-GitHub"><a class="header-anchor" href="#Hexo-部署到-GitHub">☃</a>Hexo 部署到 GitHub</h1><hr><hr><h2 id="在-GitHub-官网上创建个人仓库"><a class="header-anchor" href="#在-GitHub-官网上创建个人仓库">☃</a>在 GitHub 官网上创建个人仓库</h2><hr><p>登录 <a href="https://github.com/">GitHub 官网</a>，点击右上角加号，点击 New Repository ，新建仓库。</p><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_1453048826363041159371369.png" alt="新建仓库页面"></p><p>创建一个和账号名相同的仓库（即 <strong><a href="http://xxx.github.io">http://xxx.github.io</a></strong> ，其中 <code>xxx</code> 是 github 的账号名），点击 Greate Repository 创建。</p><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_1456556257341474192203571.png" alt="创建仓库页面"></p><hr><h2 id="Git-初始化设置"><a class="header-anchor" href="#Git-初始化设置">☃</a>Git 初始化设置</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"你的 github 账号名"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"你的 github 邮箱号"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="查看设置是否正确"><a class="header-anchor" href="#查看设置是否正确">☃</a>查看设置是否正确</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.email<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="生成-SSH-KEY-添加到-GitHub"><a class="header-anchor" href="#生成-SSH-KEY-添加到-GitHub">☃</a>生成 SSH KEY 添加到 GitHub</h2><hr><ul><li>创建 SSH Key ，默认回车，输入如下命令：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"你的邮箱号"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200802_1139583858709568397913356.jpg" alt="生成 SSH key 页面"></p><ul><li>查看 SSH key ，输入如下命令：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0950183625923031218189922.jpg" alt="SSH key 内容"></p><ul><li>复制 <code>id_rsa.pub</code> 里面的全部内容，在 GitHub 的 Setting 中，找到 SSH and GPG keys 的设置选项，点击 New SSH key，粘贴 <code>id_rsa.pub</code> 里面的全部内容。</li></ul><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0801_151404755358037895170688.png" alt="添加 SSH key 页面"></p><ul><li>查看是否连接成功，输入如下命令：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token parameter variable">-T</span> git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0950365347089596365232504.jpg" alt="连接成功页面"></p><ul><li>打开 Hexo 根目录下的配置文件 <code>_config.yml</code> ，修改添加如下内容：</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>     <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span>      <span class="token key atrule">github</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>xxx/xxx.github.io.git <span class="token comment"># `xxx` 是 github 配置的仓库名</span>    <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Hexo-部署到-GitHub-Pages"><a class="header-anchor" href="#Hexo-部署到-GitHub-Pages">☃</a>Hexo 部署到 GitHub Pages</h2><hr><ul><li>在部署到 GitHub 之前，首先安装 hexo-deployer-git 的 Hexo 插件。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>部署到 GitHub 。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述操作完成后，打开浏览器访问设置的网络地址 <strong><a href="https://xxx.github.io/">https://xxx.github.io/</a></strong> （xxx 是 github 账号昵称），就可以看见和本地网络地址 <strong><a href="http://localhost:4000">http://localhost:4000</a></strong> 一样的 Hexo 博客页面。</p><hr><h1 id="Hexo-部署到-Gitee"><a class="header-anchor" href="#Hexo-部署到-Gitee">☃</a>Hexo 部署到 Gitee</h1><hr><hr><h2 id="在-Gitee-官网上创建个人仓库"><a class="header-anchor" href="#在-Gitee-官网上创建个人仓库">☃</a>在 Gitee 官网上创建个人仓库</h2><hr><p>打开<a href="https://gitee.com/">码云官网</a>，注册登陆，创建项目，点击右上角加号，新建仓库。</p><p><img src="https://tao7app.files.wordpress.com/2023/01/151224.png" alt="创建仓库页面"></p><p>开启 Gitee Pages 服务。</p><p>![]<a href="https://tao7app.file.wordpress.com/2022/12/screenshot_2020_0802_23122156848301236150357.png">https://tao7app.file.wordpress.com/2022/12/screenshot_2020_0802_23122156848301236150357.png</a>)</p><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0937147843036425501178044.jpg" alt="Gitee Pages 服务页面"></p><p>点击启动后出现的蓝色链接就是生成的博客网址地址，每次部署都要进入 Gitee Pages 服务页面点击启动按钮才能更新更改。</p><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0802_2314342325756989210353055.png" alt="开启服务成功页面"></p><hr><h2 id="初始化-Git-设置"><a class="header-anchor" href="#初始化-Git-设置">☃</a>初始化 Git 设置</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"你的 gitee 账号名"</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"你的 gitee 邮箱号"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="查看设置是否正确-v2"><a class="header-anchor" href="#查看设置是否正确-v2">☃</a>查看设置是否正确</h2><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.email<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="生成-SSH-KEY-添加到-Gitee"><a class="header-anchor" href="#生成-SSH-KEY-添加到-Gitee">☃</a>生成 SSH KEY 添加到 Gitee</h2><hr><ul><li>创建 SSH key ，默认回车，输入如下命令：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"你的邮箱号"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200802_1139583858709568397913356.jpg" alt="生成 SSH key 页面"></p><ul><li>查看 SSH key ， 输入如下命令：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20200803_0950183625923031218189922.jpg" alt="SSH key 内容"></p><ul><li>复制 <code>id_rsa.pub</code> 里面的全部内容，在 gitee 的安全设置中，找到 <code>SSH 公钥</code> 的设置选项，添加 SSH key ，粘贴 <code>id_rsa.pub</code> 里面的全部内容。</li></ul><p><img src="https://tao7app.files.wordpress.com/2022/12/screenshot_2020_0802_2316484808107369418949929.png" alt="添加 SSH key 页面"></p><ul><li>查看是否连接成功，输入如下命令：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token parameter variable">-T</span> git@gitee.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>打开 Hexo 根目录下的 <code>_config.yml</code> 配置文件，修改添加如下内容：</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 账号名和仓库名不一致时添加如下配置形式，否则不用</span><span class="token key atrule">url</span><span class="token punctuation">:</span> Gitee Pages 服务网站地址： https<span class="token punctuation">:</span>//空间名.gitee.io/仓库名<span class="token key atrule">root</span><span class="token punctuation">:</span> /仓库名/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> git      <span class="token key atrule">repo</span><span class="token punctuation">:</span>        <span class="token key atrule">gitee</span><span class="token punctuation">:</span> git@gitee.com<span class="token punctuation">:</span>xxx/xxx.git <span class="token comment"># `xxx` 是 gitee 的账号名</span>     <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GitHub 和 Gitee 双部署的 Hexo 根目录下的配置文件 <code>_config.yml</code> 配置形式：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>     <span class="token key atrule">type</span><span class="token punctuation">:</span> git     <span class="token key atrule">repo</span><span class="token punctuation">:</span>       <span class="token key atrule">github</span><span class="token punctuation">:</span> git@githun.com/cqupthao/cqupthao.github.io.git  <span class="token comment"># cqupthao 为账号名</span>       <span class="token key atrule">gitee</span><span class="token punctuation">:</span> git@gitee.com/cqupthao/cqupthao.git  <span class="token comment"># cqupthao 为账号名</span>     <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="Hexo-部署到-Gitee-Pages"><a class="header-anchor" href="#Hexo-部署到-Gitee-Pages">☃</a>Hexo 部署到 Gitee Pages</h2><hr><ul><li>在部署到 Gitee 之前，首先安装 hexo-deployer-git 的 Hexo 插件。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>部署到 Gitee 。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述操作完成后，打开浏览器访问设置的网络地址 <strong><a href="https://xxx.gitee.io/">https://xxx.gitee.io/</a></strong> （<code>xxx</code> 是 gitee 账户号），就可以看见和本地网址地址 <strong><a href="http://localhost:4000">http://localhost:4000</a></strong> 一样的 Hexo 博客页面。</p><hr><ul><li>参考<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a></li></ul><hr><h1 id="Matery-主题安装及优化"><a class="header-anchor" href="#Matery-主题安装及优化">☃</a>Matery 主题安装及优化</h1><hr><ul><li><p>Matery 主题安装参考 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">Matery 官网教程</a>。</p></li><li><p>Matery 优化参考 <a href="https://blog.17lai.site/posts/40300608/">基于 Hexo 的 Matery 主题搭建博客并深度优化一站式完全教程</a>。</p></li></ul><hr><h1 id="Hexo-插件的安装"><a class="header-anchor" href="#Hexo-插件的安装">☃</a>Hexo 插件的安装</h1><hr><hr><h2 id="代码高亮"><a class="header-anchor" href="#代码高亮">☃</a>代码高亮</h2><hr><p>从 Hexo5.0 版本开始自带了 prismjs 代码语法高亮的支持，如果博客安装过 <code>hexo-prism-plugin</code> 的插件，须执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>修改 Hexo 根目录下 <code>_config.yml</code> 文件中 highlight.enable 的值为 false ，并将 prismjs.enable 的值设置为 true ，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主题中默认的 prismjs 主题是 Tomorrow Night ，如果想定制自己的主题，可前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a>  定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 <code>css</code> 主题文件取名为 <code>prism.css</code>，替换掉 Matery 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件。</p><hr><h2 id="搜索"><a class="header-anchor" href="#搜索">☃</a>搜索</h2><hr><p>使用 <code>hexo-generator-search</code> 的 Hexo 插件来实现内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="中文链接转拼音"><a class="header-anchor" href="#中文链接转拼音">☃</a>中文链接转拼音</h2><hr><p>使用 <code>hexo-permalink-pinyin</code> 的 Hexo 插件使在生成文章时生成中文拼音的永久链接，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以生成拼音链接。</p><hr><h2 id="文章生成永久链接"><a class="header-anchor" href="#文章生成永久链接">☃</a>文章生成永久链接</h2><hr><p>使用 <code>hexo-abbrlink</code> 的 Hexo 插件来实现文章生成永久链接，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">abbrlink</span><span class="token punctuation">:</span>     <span class="token key atrule">alg</span><span class="token punctuation">:</span> crc16 <span class="token comment">#算法：</span>    <span class="token key atrule">rep</span><span class="token punctuation">:</span> hex <span class="token comment">#输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将 <code>_config.yml</code> 文件中的 permalink 的值修改为如下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink</span><span class="token punctuation">:</span> posts/<span class="token punctuation">:</span>abbrlink.html  <span class="token comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以生成永久链接。生成完后，原 md 文件的 Front-matter 内会增加 abbrlink 字段，值为生成的 ID 。</p><hr><h2 id="外链跳转"><a class="header-anchor" href="#外链跳转">☃</a>外链跳转</h2><hr><p>使用 <code>hexo-external-link</code> 的 Hexo 插件来实现外链跳转，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-external-link <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">hexo_external_link</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">enable_base64_encode</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">url_param_name</span><span class="token punctuation">:</span> <span class="token string">'u'</span>  <span class="token key atrule">html_file_name</span><span class="token punctuation">:</span> <span class="token string">'go.html'</span>  <span class="token key atrule">target_blank</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">link_rel</span><span class="token punctuation">:</span> <span class="token string">'external nofollow noopener noreferrer'</span>  <span class="token key atrule">domain</span><span class="token punctuation">:</span> <span class="token string">'your_domain'</span> <span class="token comment"># 如果开启了防盗链，填写你的域名</span>  <span class="token key atrule">safety_chain</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现外链跳转。</p><hr><h2 id="文章字数统计"><a class="header-anchor" href="#文章字数统计">☃</a>文章字数统计</h2><hr><p>使用 <code>hexo-wordcount</code> 的 Hexo 插件来实现在文章中统计显示文章字数、阅读时长信息，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-wordcount <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Matery 主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true </span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现文章字数统计。</p><hr><h2 id="添加-Emoji-表情支持"><a class="header-anchor" href="#添加-Emoji-表情支持">☃</a>添加 Emoji 表情支持</h2><hr><p>使用 <code>hexo-filter-github-emojis</code> 的 Hexo 插件来支持 emoji 表情的生成，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中用 emoji 语法写表情。</p><hr><h2 id="添加-RSS-订阅支持"><a class="header-anchor" href="#添加-RSS-订阅支持">☃</a>添加 RSS 订阅支持</h2><hr><p>使用 <code>hexo-generator-feed</code> 的 Hexo 插件来做 RSS，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，在 <code>public</code> 文件夹中看到 <code>atom.xml</code> 文件，说明已安装成功。</p><hr><h2 id="图片懒加载"><a class="header-anchor" href="#图片懒加载">☃</a>图片懒加载</h2><hr><p>使用 <code>hexo-lazyload-image</code> 的 Hexo 插件来实现图片懒加载，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-lazyload-image <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">lazyload</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>   <span class="token key atrule">onlypost</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token comment"># 是否只对文章的图片做懒加载</span>  <span class="token key atrule">loadingImg</span><span class="token punctuation">:</span> <span class="token comment"># eg ./images/loading.gif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，一般情况下懒加载会和 gallery 插件会发生冲突，结果可能就是点开图片，左右翻都是 loading image 。解决方法：<br>修改 <code>/themes/matery/source/js</code> 中的 <code>matery.js</code> 文件在第 108 行加上如下内容。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'img[data-original]'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">,</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"data-original"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>做完这步之后，还有点小 Bug ，首页的 logo 点击会直接打开 logo 图，而不是跳到首页。伪解决方案：打开  <code>/themes/matery/layout/_partial/header.ejs</code> 文件，在 img 和 span 的两个头加个 div 。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;div class="brand-logo"&gt;    &lt;a href="&lt;%- url_for() %&gt;" class="waves-effect waves-light"&gt;        &lt;div&gt;            &lt;% if (theme.logo !== undefined &amp;&amp; theme.logo.length &gt; 0) { %&gt;            &lt;img src="&lt;%= theme.logo %&gt;" class="logo-img" alt="LOGO"&gt;            &lt;% } %&gt;            &lt;span class="logo-span"&gt;&lt;%- config.title %&gt;&lt;/span&gt;        &lt;/div&gt;    &lt;/a&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现图片懒加载。</p><hr><h2 id="折叠功能"><a class="header-anchor" href="#折叠功能">☃</a>折叠功能</h2><hr><p>使用 <code>hexo-sliding-spoiler</code> 的 Hexo 插件来实现折叠功能，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-sliding-spoiler <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">plugin</span><span class="token punctuation">:</span><span class="token punctuation">-</span> hexo<span class="token punctuation">-</span>sliding<span class="token punctuation">-</span>spoiler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现折叠功能。</p><hr><h2 id="代码压缩"><a class="header-anchor" href="#代码压缩">☃</a>代码压缩</h2><hr><p>使用 <code>hexo-neat</code> 的 Hexo 插件来实现代码压缩，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-neat <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#hexo-neat 优化提速插件（去掉 HTML、css、js 的 blank字符）</span><span class="token key atrule">neat_enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">neat_html</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">'**/*.md'</span><span class="token key atrule">neat_css</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">'**/*.min.css'</span><span class="token key atrule">neat_js</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">mangle</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">output</span><span class="token punctuation">:</span>  <span class="token key atrule">compress</span><span class="token punctuation">:</span>  <span class="token key atrule">exclude</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">'**/*.min.js'</span>    <span class="token punctuation">-</span> <span class="token string">'**/**/instantpage.js'</span>    <span class="token punctuation">-</span> <span class="token string">'**/matery.js'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，就可以实现代码压缩了。</p><hr><p>Hexo 插件安装参考 <a href="https://hexo.io/plugins">Hexo 官网</a></p><hr><h1 id="Hexo-添加-Valine-评论系统"><a class="header-anchor" href="#Hexo-添加-Valine-评论系统">☃</a>Hexo 添加 Valine 评论系统</h1><hr><hr><h2 id="Valine-简介"><a class="header-anchor" href="#Valine-简介">☃</a>Valine 简介</h2><hr><p><a href="https://valine.js.org/">valine</a>  诞生于 2017 年 8 月 7 日，是一款基于  <a href="https://www.leancloud.cn/">LeanCloud</a>  的快速、简洁且高效的无后端评论系统。理论上支持但不限于静态博客，目前已有 Hexo 、Jekyll 、Typecho 、Hugo 、Ghost 等博客程序在使用  <a href="https://valine.js.org/">valine</a> 。</p><p>valine 具有快速安全，Emoji 😉，无后端实现，MarkDown 全语法支持，轻量易用，文章阅读量统计等优质特性。</p><hr><h2 id="Valine-的配置"><a class="header-anchor" href="#Valine-的配置">☃</a>Valine 的配置</h2><hr><ul><li>在 <a href="https://console.leancloud.cn/">LeanCloud 官网</a>注册登录，创建一个应用，然后进入应用，点击设置，找到应用凭证，复制 AppID 和 AppKey 到 Matery 主题的 <code>config.yml</code> 配置文件中的对应位置。</li></ul><p><img src="https://tao7app.files.wordpress.com/2023/01/02017.png" alt="AppID 和 AppKey"></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey 。</span><span class="token key atrule">valine</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">appId</span><span class="token punctuation">:</span>  <span class="token comment"># 将应用 key 的 AppID 设置在这里</span>  <span class="token key atrule">appKey</span><span class="token punctuation">:</span> <span class="token comment"># 将应用 key 的 AppKey 设置在这里</span>  <span class="token key atrule">serverURLs</span><span class="token punctuation">:</span>  <span class="token comment"># https://你的api</span>  <span class="token key atrule">notify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 邮箱通知</span>  <span class="token key atrule">verify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 验证码 默认为 false</span>  <span class="token key atrule">visitor</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 是否允许游客评论</span>  <span class="token key atrule">avatar</span><span class="token punctuation">:</span> <span class="token string">'mm'</span> <span class="token comment"># 头像风格，默认为 mm ，可进入网址: mm/identicon/monsterid/wavatar/retro/hide</span>  <span class="token key atrule">pageSize</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">placeholder</span><span class="token punctuation">:</span> <span class="token string">'just go go'</span> <span class="token comment"># Comment Box placeholder</span>  <span class="token key atrule">background</span><span class="token punctuation">:</span> /medias/comment_bg.png  <span class="token key atrule">coolpushkey</span><span class="token punctuation">:</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>升级 valine 版本。</li></ul><p>进入 <a href="https://unpkg.com/valine/dist/">valine 官网</a>， 选择 valine 版本后点击 <code>Valine.min.js</code> ，点击 View Raw 后复制 全部内容，粘贴替换 Matery 主题下的 <code>/source/libs/valine/Valine.min.js</code> 文件全部内容。</p><p><img src="https://tao7app.files.wordpress.com/2023/01/135.png" alt="Valine.min.js 内容页面"></p><p>修改 Matery 主题目录下的 <code>_comfig.yml</code> 配置文件如下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">valine</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">appId</span><span class="token punctuation">:</span> iTxfqh5e9IaRfiiVOTbIWoKa<span class="token punctuation">-</span>XXXXXX  <span class="token key atrule">appKey</span><span class="token punctuation">:</span> C5s5xGFErD1EtXXXXXXXX  <span class="token key atrule">verify</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 是否启用防垃圾验证</span>  <span class="token key atrule">notify</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 是否开启邮件提醒(https://valine.js.org/notify.html)</span>  <span class="token key atrule">visitor</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">avatar</span><span class="token punctuation">:</span> monsterid  <span class="token comment"># 头像样式(https://valine.js.org/avatar.html) </span>  <span class="token key atrule">pageSize</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">placeholder</span><span class="token punctuation">:</span> <span class="token string">'ヾﾉ≧∀≦)o来啊，快活啊!'</span> <span class="token comment"># Comment Box placeholder</span>  <span class="token key atrule">background</span><span class="token punctuation">:</span> /medias/comment_bg.png <span class="token comment">#背景图</span>  <span class="token key atrule">count</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">enableQQ</span><span class="token punctuation">:</span> <span class="token number">2733443175</span>  <span class="token key atrule">recordIP</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">requiredFields</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> nick    <span class="token punctuation">-</span> mail  <span class="token key atrule">guest_info</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> nick    <span class="token punctuation">-</span> mail    <span class="token punctuation">-</span> link  <span class="token key atrule">master</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> 123abc508165c8eba9a77f872xxxx046  <span class="token comment"># MD5 加密后的博主邮箱</span>  <span class="token key atrule">metaPlaceholder</span><span class="token punctuation">:</span>  <span class="token comment"># 输入框的背景文字</span>    <span class="token key atrule">nick</span><span class="token punctuation">:</span> 昵称 / QQ 号（必填）    <span class="token key atrule">mail</span><span class="token punctuation">:</span> 邮箱（用于获取通知信息）    <span class="token key atrule">link</span><span class="token punctuation">:</span>   <span class="token key atrule">lang</span><span class="token punctuation">:</span> zh<span class="token punctuation">-</span>CN  <span class="token key atrule">tagMeta</span><span class="token punctuation">:</span> <span class="token comment"># The String Array of Words to show Flag ，[Just Only xCss Style modle]</span>    <span class="token punctuation">-</span> 博主    <span class="token punctuation">-</span> 小伙伴    <span class="token punctuation">-</span> 访客<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>valine 配置参数信息参考 <a href="https://valine.js.org/">valine 官方文档</a></p><hr><ul><li>管理评论。</li></ul><p>点击 <code>存储 -&gt; 结构化数据</code> ，选择创建 Class ，名称  <code>Comment</code> ，其它保持默认，以后 Hexo 博客的评论就可在这个 Class 内查看，删除等。</p><p><img src="https://tao7app.files.wordpress.com/2023/01/40522.png" alt="创建 Comment"></p><ul><li>文章阅读量统计。</li></ul><p>点击 <code>存储 -&gt; 结构化数据</code> ，选择创建 Class ，名称 <code>Counter</code> ，其它保持默认，以后就可在这个 Class 内查看。</p><p><img src="https://tao7app.files.wordpress.com/2023/01/40502.png" alt="创建 Counter"></p><hr><h2 id="增加点击跳转评论按钮"><a class="header-anchor" href="#增加点击跳转评论按钮">☃</a>增加点击跳转评论按钮</h2><hr><p>在 Matery 主题目录 <code>/layout/_partial/</code>  下新建 <code>back-comment.ejs</code> 文件 , 复制粘贴如下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 直达评论 <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"to_comment"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"comment-scroll"</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"btn-floating btn-large waves-effect waves-light"</span> href<span class="token operator">=</span><span class="token string">"#vcomments"</span> title<span class="token operator">=</span><span class="token string">"直达评论"</span><span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"fas fa-comments"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Matery 主题目录 <code>/layout/_partial/</code>  下的 <code>valine.ejs</code> 文末添加一条如下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/back-comment.ejs'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只有 valine 存在的页面才显示直达评论，为了防止首页其它地方也出现按钮，在 Matery 主题目录 <code>/source/css/</code> 下的 <code>matery.css</code> 文件添加如下内容：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*直达评论按钮样式*/</span><span class="token selector">.comment-scroll</span> <span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span> 135px<span class="token punctuation">;</span> # bottom ：135px 是距离底部的高度    <span class="token property">padding-top</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>    <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    <span class="token property">z-index</span><span class="token punctuation">:</span> 998<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.comment-scroll .btn-floating</span> <span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to bottom right<span class="token punctuation">,</span> #FF9999 0%<span class="token punctuation">,</span> #ff6666 100%<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 48px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 48px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.comment-scroll .btn-floating i</span> <span class="token punctuation">{</span>    <span class="token property">line-height</span><span class="token punctuation">:</span> 48px<span class="token punctuation">;</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> 1.8rem<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="实现-Valine-评论系统通知功能"><a class="header-anchor" href="#实现-Valine-评论系统通知功能">☃</a>实现 Valine 评论系统通知功能</h1><hr><p>Valine-Admin 项目是一个对  <a href="https://valine.js.org/">valine</a>  评论系统的拓展应用，可以增强 valine 的邮件通知功能。基于 LeanCloud 的云引擎与云函数，主要实现评论邮件通知、评论管理、自定义邮件通知模板等功能，还可以提供邮件 <code>通知站长</code> 和 <code>@通知</code> 的功能。具体操作如下：</p><ul><li><p>确保 valine 的基础功能是是否正常，参考 <a href="https://valine.js.org/">valine 官方文档</a>。</p></li><li><p>进入 <a href="https://leancloud.cn/dashboard/applist.html#/apps">LeanCloud</a>  对应的 valine 应用中。</p></li><li><p>点击 <code>云引擎 -&gt; 部署</code> ，选择 <code>Git 源码部署</code> ，填写仓库地址 <code>https://github.com/HCLonely/Valine-Admin</code> ，点击保存，分支或版本号输入 <code>master</code> ，下载最新依赖（可选），点击部署。</p></li></ul><p><img src="https://tao7app.files.wordpress.com/2023/01/0547.png" alt="部署页面"></p><ul><li>设置 <code>自定义环境变量</code> ，需要设置云引擎的环境变量以提供必要的信息，变量参数参考下面的 <code>配置项表</code> ：</li></ul><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SITE_NAME</td><td style="text-align:left">blog</td><td style="text-align:left">[必填] 网站名称</td></tr><tr><td style="text-align:left">SITE_URL</td><td style="text-align:left"><a href="https://xxx.github.io">https://xxx.github.io</a></td><td style="text-align:left">[必填] 网站地址，最后不要加 /</td></tr><tr><td style="text-align:left">SMTP_SERVICE</td><td style="text-align:left">QQ</td><td style="text-align:left">[必填] 邮件服务提供商，支持 QQ、163、126、Gmail 以及更多</td></tr><tr><td style="text-align:left">SMTP_USER</td><td style="text-align:left"><a href="mailto:xxxx@qq.com">xxxx@qq.com</a></td><td style="text-align:left">[必填] SMTP登录用户，一般为邮箱地址</td></tr><tr><td style="text-align:left">SMTP_PASS</td><td style="text-align:left">xxxx</td><td style="text-align:left">[必填] SMTP登录密码，QQ 授权码,<a href=""></a></td></tr><tr><td style="text-align:left">SENDER_NAME</td><td style="text-align:left">Valine 评论提醒</td><td style="text-align:left">[可选] 通知模板</td></tr><tr><td style="text-align:left">ADMIN_URL</td><td style="text-align:left"><a href="https://xxx.leanapp.cn/">https://xxx.leanapp.cn/</a></td><td style="text-align:left">[建议] Web 主机二级域名，用于自动唤醒</td></tr><tr><td style="text-align:left">TO_EMAIL</td><td style="text-align:left"><a href="mailto:xxxxx@gmail.com">xxxxx@gmail.com</a></td><td style="text-align:left">[可选] 指定站长收信邮箱，默认值为 SITE_USER ，用于 SMTP 发件人与站长收件人不一致的情况下使用</td></tr><tr><td style="text-align:left">TEMPLATE_NAME</td><td style="text-align:left">rainbow</td><td style="text-align:left">[可选] 通知邮件的模板（default 和 rainbow），参考高级功能</td></tr></tbody></table><hr><p><img src="https://tao7app.files.wordpress.com/2023/01/706.png" alt="自定义环境变量页面"></p><ul><li>设置后台管理登录信息，点击 <code>存储 -&gt; 结构化数据</code> ，选择 <code>_User -&gt; 添加行</code> ，只需要填写 <code>password</code> 、<code>username</code> 、<code>email</code> 这三个字段即可, 使用 email 作为账号登陆、password 作为账号密码、username 任意即可。（为了安全考虑，此 email 必须为配置中的 <code>SMTP_USER</code> 或 <code>TO_EMAIL</code> ，否则不允许登录）</li></ul><p><img src="https://tao7app.files.wordpress.com/2023/01/35744.png" alt="valine 评论通知效果"></p><hr><p>参考 <a href="https://blog.17lai.site/posts/9b056c86/">基于 Hexo 的 matery 主题搭建博客个性定制篇</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> Matery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Valine </tag>
            
            <tag> Hexo </tag>
            
            <tag> Gitee </tag>
            
            <tag> Matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown 语法</title>
      <link href="/posts/62652.html"/>
      <url>/posts/62652.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="MarkDown-概述"><a class="header-anchor" href="#MarkDown-概述">☃</a>MarkDown 概述</h2><hr><h3 id="宗旨"><a class="header-anchor" href="#宗旨">☃</a>宗旨</h3><p><strong>MarkDown</strong> 的目标是实现「易读易写」。</p><p>一份使用 MarkDown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。</p><h3 id="兼容-HTML"><a class="header-anchor" href="#兼容-HTML">☃</a>兼容 HTML</h3><p><strong>MarkDown</strong> 语法的目标是：成为一种适用于网络的书写语言。</p><p>MarkDown 的构想不是要使得 HTML 文档更容易书写。MarkDown 的设计理念是，能让文档更容易读、写和随意改。</p><hr><h2 id="标题"><a class="header-anchor" href="#标题">☃</a>标题</h2><hr><p>MarkDown 标题有两种格式：</p><ol><li>使用 <strong>=</strong> 和 <strong>-</strong> 标记一级和二级标题。</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token title important">我展示的是一级标题<span class="token punctuation">=================</span></span><span class="token title important">我展示的是二级标题<span class="token punctuation">-----------------</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> 一级标题</span><span class="token title important"><span class="token punctuation">##</span> 二级标题</span><span class="token title important"><span class="token punctuation">###</span> 三级标题</span><span class="token title important"><span class="token punctuation">####</span> 四级标题</span><span class="token title important"><span class="token punctuation">#####</span> 五级标题</span><span class="token title important"><span class="token punctuation">######</span> 六级标题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="段落与文本换行"><a class="header-anchor" href="#段落与文本换行">☃</a>段落与文本换行</h2><hr><p>Markdown 段落没有特殊的格式,直接编写文字, 段落换行是使用两个以上的空格加上回车/使用一个空行重新开始一个新的段落/使用 HTML 标签 <code>&lt;br&gt;</code> 。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> 段落 (两个空格+回车)  <span class="token list punctuation">2.</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span> 段落 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>br</span><span class="token punctuation">&gt;</span></span>（使用 HTML 语言换行标签）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="文本添加缩进"><a class="header-anchor" href="#文本添加缩进">☃</a>文本添加缩进</h2><hr><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">#使用 HTML 标签 &lt;style&gt; 实现&lt;p style="text-indent:1em"&gt;你好呀&lt;/p&gt;&lt;p style="text-indent:2em"&gt;你好呀&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><p style="text-indent:1em">你好呀</p><p style="text-indent:2em">你好呀</p><hr><h2 id="字体"><a class="header-anchor" href="#字体">☃</a>字体</h2><hr><p>MarkDown 可以使用以下几种字体：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span><span class="token content">斜体文本</span><span class="token punctuation">*</span></span><span class="token bold"><span class="token punctuation">**</span><span class="token content">粗体文本</span><span class="token punctuation">**</span></span><span class="token bold"><span class="token punctuation">**</span><span class="token content"><span class="token italic"><span class="token punctuation">*</span><span class="token content">粗斜体文本</span><span class="token punctuation">*</span></span></span><span class="token punctuation">**</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="高亮"><a class="header-anchor" href="#高亮">☃</a>高亮</h2><hr><p>MarkDown 使用连续两个单号包括高亮的部分实现内容的高亮。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">==高亮内容==<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="分割线"><a class="header-anchor" href="#分割线">☃</a>分割线</h2><hr><p>在一行中用三个以上的 <strong>星号</strong>、<strong>减号</strong>、<strong>底线</strong> 来建立一个分隔线，行内不能有其他东西或在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">-</span> ***<span class="token hr punctuation">- ---</span><span class="token list punctuation">-</span> ···<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="删除线"><a class="header-anchor" href="#删除线">☃</a>删除线</h2><hr><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线即可。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">~~delete<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="下划线"><a class="header-anchor" href="#下划线">☃</a>下划线</h2><hr><p>下划线可以通过 <strong>HTML</strong> 的标签来实现。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;u&gt;带下划线文本&lt;/u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="注释"><a class="header-anchor" href="#注释">☃</a>注释</h2><hr><p>使用 <strong>HTML</strong> 的注释方式。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!-- 注释 --&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="脚注"><a class="header-anchor" href="#脚注">☃</a>脚注</h2><hr><p>脚注是对文本的补充说明，MarkDown 脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">创建脚注格式 [^1] [^1] : 菜鸟教程 -- 学的不仅是技术，更是梦想!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="文本居中"><a class="header-anchor" href="#文本居中">☃</a>文本居中</h2><hr><p>使用 <strong>HTML</strong> 可以将文本居中。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;center&gt;居中的内容&lt;/center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="列表"><a class="header-anchor" href="#列表">☃</a>列表</h2><hr><p>MarkDown 支持有序列表和无序列表。</p><ul><li>有序列表</li></ul><p>有序列表使用数字并加上 <strong>.</strong> 号来表示。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">1.</span> 第一项<span class="token list punctuation">2.</span> 第二项<span class="token list punctuation">3.</span> 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>无序列表</li></ul><p>无序列表使用 <strong>星号</strong> （ <code>*</code> ）、<strong>加号</strong> （ <code>+</code> ）或是 <strong>减号</strong> （ <code>-</code> ）作为列表标记。</p> <pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">*</span> 第一项<span class="token list punctuation">*</span> 第二项<span class="token list punctuation">*</span> 第三项------ 分割线 ------<span class="token list punctuation">-</span> 第一项<span class="token list punctuation">-</span> 第二项<span class="token list punctuation">-</span> 第三项------ 分割线 ------<span class="token list punctuation">+</span> 第一项<span class="token list punctuation">+</span> 第二项<span class="token list punctuation">+</span> 第三项  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="区块"><a class="header-anchor" href="#区块">☃</a>区块</h2><hr><ol><li>区块引用</li></ol><p>MarkDown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟 <strong>一个空格符号</strong> 。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token blockquote punctuation">&gt;</span> 区块引用<span class="token blockquote punctuation">&gt;</span> 菜鸟教程<span class="token blockquote punctuation">&gt;</span> 学的不仅是技术更是梦想<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>区块使用列表</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token blockquote punctuation">&gt;</span> 区块中使用列表<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">1.</span> 第一项<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">2.</span> 第二项<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">+</span> 第一项<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">+</span> 第二项<span class="token blockquote punctuation">&gt;</span> <span class="token list punctuation">+</span> 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>列表中使用区块</li></ol><p>如果要在列表项目内放进区块，那么就需要在 <strong>&gt;</strong> 前添加四个空格的缩进。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token list punctuation">*</span> 第一项  &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想<span class="token list punctuation">*</span> 第二项     &gt;欢迎光临<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="代码与代码块"><a class="header-anchor" href="#代码与代码块">☃</a>代码与代码块</h2><hr><ol><li>单行代码</li></ol><p>如果是单行代码或段落上的一个函数或片段的代码可以用 <strong>反引号对</strong> 把它括起来。</p><p><code>fmt.Println("Hello Word!)</code></p><ol start="2"><li>代码区块</li></ol><p>代码区块使用 <strong>三个反引号对</strong> 包裹一段代码，并指定一种语言（也可以不指定）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="上标与下标"><a class="header-anchor" href="#上标与下标">☃</a>上标与下标</h2><hr><ol><li>上标使用双 <strong>^</strong> 括住内容</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">x^2^<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>下标使用双 <strong>~</strong> 括住内容</li></ol><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">H2<span class="token strike"><span class="token punctuation">~</span><span class="token content">0</span><span class="token punctuation">~</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="超链接"><a class="header-anchor" href="#超链接">☃</a>超链接</h2><hr><ul><li><p>一个方括号 <strong>[]</strong> ，里面放上链接的替代文字</p></li><li><p>接着一个普通括号 <strong>()</strong> ，里面放上网址</p></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 <span class="token url">[<span class="token content">Google</span>][<span class="token variable">1</span>]</span>这个链接用 baidu 作为网址变量 <span class="token url">[<span class="token content">百度</span>][<span class="token variable">baidu</span>]</span>然后在文档的结尾为变量赋值（网址）[1]:http://www.google.com/[baidu]:http://www.baidu.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="插入图片"><a class="header-anchor" href="#插入图片">☃</a>插入图片</h2><hr><ul><li><p>开头一个 感叹号 <strong>!</strong></p></li><li><p>接着一个 方括号 <strong>[]</strong> ，里面放上图片的替代文字</p></li><li><p>接着一个 普通括号 <strong>()</strong> ，里面放上图片的网址，最后还可以用 <strong>引号</strong> 包住并加上选择性的 <strong>title</strong> 属性的文字</p></li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token url"><span class="token operator">!</span>[<span class="token content">图片</span>](<span class="token url">http://xxx.com/xxx.png</span>)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><img src="https://tao7app.files.wordpress.com/2022/12/img_20221210_145354.jpg" alt="图片"></p><hr><h2 id="设置图片"><a class="header-anchor" href="#设置图片">☃</a>设置图片</h2><hr><p>通过 center 居中，把 center 换成 left 和 right 可以实现居左或者居右，width 和 height 调控高度和宽度。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;div align=center&gt;&lt;img src="http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg" width="251" height="350"&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><div align="center"><img src="http://pic11.photophoto.cn/20090626/0036036341009653_b.jpg" width="251" height="350"></div><hr><hr><h2 id="插入视频"><a class="header-anchor" href="#插入视频">☃</a>插入视频</h2><hr><p>插入视频实现依赖于 <strong>HTML</strong> 。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;video controls="" autoplay="" name="media"&gt;    &lt;source src="https://www.w3school.com.cn/example/html5/mov_bbb.mp4" type="video/mp4"&gt;&lt;/video&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p><video controls="" autoplay="" name="media">    <source src="https://www.w3school.com.cn/example/html5/mov_bbb.mp4" type="video/mp4"><br></video></p><hr><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;iframe    width=100%    height=120px    src='//player.bilibili.com/player.html?aid=455564468&amp;bvid=BV1H541147nA&amp;cid=187808769&amp;page=1'    frameborder="0"    allowfullscreen&gt;&lt;/iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><iframe width="100%" height="120px" src="//player.bilibili.com/player.html?aid=455564468&amp;bvid=BV1H541147nA&amp;cid=187808769&amp;page=1" frameborder="0" allowfullscreen=""></iframe><hr><ul><li><p>src 里面填视频原 URL</p></li><li><p>width 是视频宽度（可以填百分比）</p></li><li><p>height 是视频高度（可以填百分比）</p></li></ul><hr><h2 id="插入音乐"><a class="header-anchor" href="#插入音乐">☃</a>插入音乐</h2><hr><p>插入音乐实现依赖于 <strong>HTML</strong> 。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;div align=center&gt;&lt;iframe frameborder="no" marginwidth="0" marginheight="0" width=300 height=90 src="https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><div align="center"><iframe frameborder="no" marginwidth="0" marginheight="0" width="300" height="90" src="https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66"></iframe></div><ul><li><p>div 用于控制格式，若无则默认为居左</p></li><li><p>frameborder 用于规定是否显示框架周围的边框，1 为是，0 为否</p></li><li><p>marginwidth 及 marginheight 表示距离边缘的像素大小</p></li><li><p>width 及 height 表示播放条的长度和宽度 src 为播放链接，可以在如网易云音乐的生成外链播放器获取该链接，同时也获得以下代码，并可以自行更改；也可将音频链接改为视频链接，从而播放视频</p></li></ul><hr><h2 id="插入表格"><a class="header-anchor" href="#插入表格">☃</a>插入表格</h2><hr><p>输入 <code>|</code> 表头1 <code>|</code> 表头2 <code>|</code> 并回车,即可创建一个包含 2 列表。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token table"><span class="token table-header-row"><span class="token punctuation">|</span><span class="token table-header important"> 左对齐 </span><span class="token punctuation">|</span><span class="token table-header important"> 右对齐 </span><span class="token punctuation">|</span><span class="token table-header important"> 中对齐 </span><span class="token punctuation">|</span></span><span class="token table-line"><span class="token punctuation">|</span> <span class="token punctuation">:----</span> <span class="token punctuation">|</span> <span class="token punctuation">----:</span> <span class="token punctuation">|</span> <span class="token punctuation">:---:</span> <span class="token punctuation">|</span></span><span class="token table-data-rows"><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span><span class="token table-data"> 单元格 </span><span class="token punctuation">|</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行。</p></li><li><p>列与列之间用管道符号 <code>|</code> 隔开，如果不使用对齐标记，内容默认左对齐，表头居中对齐</p></li></ul><hr><blockquote><p>-: 设置内容和标题栏居右对齐</p></blockquote><blockquote><p>:- 设置内容和标题栏居左对齐</p></blockquote><blockquote><p>:-: 设置内容和标题栏居中对齐</p></blockquote><hr><ul><li><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界</p></li><li><p>为了使 MarkDown 更清晰，<code>|</code> 和 <code>-</code> 两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code> 外不需要）</p></li></ul><hr><h2 id="MarkDown-编写博文的更多技巧"><a class="header-anchor" href="#MarkDown-编写博文的更多技巧">☃</a>MarkDown 编写博文的更多技巧</h2><hr><h3 id="1-支持-HTML-元素"><a class="header-anchor" href="#1-支持-HTML-元素">☃</a>1. 支持 HTML 元素</h3><p>不在 MarkDown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><h3 id="2-转义"><a class="header-anchor" href="#2-转义">☃</a>2. 转义</h3><p>MarkDown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，MarkDown 使用反斜杠转义特殊字符。</p><p>MarkDown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号:</p><hr><ul><li><strong>\ 反斜线</strong></li><li><strong>` 反引号</strong></li><li><strong>星号 [*]</strong></li><li><strong>下划线</strong></li><li><strong>{} 花括号</strong></li><li><strong>[] 方括号</strong></li><li><strong>() 小括号</strong></li><li><strong># 井字号</strong></li><li><strong>+ 加号</strong></li><li><strong>- 减号</strong></li><li><strong>. 英文句点</strong></li><li><strong>! 感叹号</strong></li></ul><hr><h2 id="文字颜色、大小、字体背景色"><a class="header-anchor" href="#文字颜色、大小、字体背景色">☃</a>文字颜色、大小、字体背景色</h2><hr><h3 id="1-字体大小"><a class="header-anchor" href="#1-字体大小">☃</a>1. 字体大小</h3><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">size为1：&lt;font size="1"&gt;size为1&lt;/font&gt;                                     size为3：&lt;font size="3"&gt;size为3&lt;/font&gt;size为4：&lt;font size="4"&gt;size为4&lt;/font&gt;size为6：&lt;font size="6"&gt;size为6&lt;/font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>size为1：<font size="1">size为1</font></p><p>size为3：<font size="3">size为3</font></p><p>size为4：<font size="4">size为4</font></p><p>size为6：<font size="6">size为6</font></p><hr><h3 id="2-颜色"><a class="header-anchor" href="#2-颜色">☃</a>2.颜色</h3><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;font color="#dd0000"&gt;文字颜色&lt;/font&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><font color="#dd0000">文字颜色</font></p><hr><h3 id="3-背景色"><a class="header-anchor" href="#3-背景色">☃</a>3.背景色</h3><p>MarkDown 本身不支持背景色设置，需要采用内置 HTMML 的方式实现：借助 <code>table</code> , <code>tr</code> , <code>td</code> 等表格标签的 bgcolor 属性来实现背景色的功能。</p><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF83FA&gt;背景色的设置是按照十六进制颜色值：#FF83FA&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;背景色的设置是按照十六进制颜色值：#D1EEEE&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#C0FF3E&gt;背景色的设置是按照十六进制颜色值：#C0FF3E&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#54FF9F&gt;背景色的设置是按照十六进制颜色值：#54FF9F&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><table><tbody><tr><td bgcolor="orange">背景色是：orange</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FF00FF">背景色的设置是按照十六进制颜色值：#7FFFD4</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FF83FA">背景色的设置是按照十六进制颜色值：#FF83FA</td></tr></tbody></table><table><tbody><tr><td bgcolor="#D1EEEE">背景色的设置是按照十六进制颜色值：#D1EEEE</td></tr></tbody></table><table><tbody><tr><td bgcolor="#C0FF3E">背景色的设置是按照十六进制颜色值：#C0FF3E</td></tr></tbody></table><table><tbody><tr><td bgcolor="#54FF9F">背景色的设置是按照十六进制颜色值：#54FF9F</td></tr></tbody></table><hr><hr><h2 id="使用-LaTex-数学公式"><a class="header-anchor" href="#使用-LaTex-数学公式">☃</a>使用 LaTex 数学公式</h2><hr><h3 id="1-行内公式"><a class="header-anchor" href="#1-行内公式">☃</a>1.行内公式</h3><p>使用两个 <strong>$</strong> 符号引用公式。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$公式$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-行间公式"><a class="header-anchor" href="#2-行间公式">☃</a>2.行间公式</h3><p>使用两对 <strong>$$</strong> 符号引用公式。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">$$公式$$ <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <a href="https://www.mathjax.org/">MarkDown 数学符号官网</a>使用中，详细介绍了一些常用的数学公式。</p><hr><p>更多内容参考 <a href="http://markdown.p2hp.com/basic-syntax/">MarkDown 中文网</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
