<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Go Web 编程原理, 韜の道"><meta name="description" content="
¶WEB 编程原理


¶Web 服务器的工作过程

一个 Web 服务器也被称为 HTTP 服务器，它通过 HTTP 协议与客户端进行通信。客户端与服务器之间的通信是非持久连接的，当服务器发送了应答后就与客户端断开连接，等待下一次请求。"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer-when-downgrade"><title>Go Web 编程原理 | 韜の道</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload='"all"!=media&&(media="all")'><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" type="text/css" href="/css/reward.css"><script src="/libs/jquery/jquery-3.6.0.min.js"></script><meta name="generator" content="Hexo 5.4.2"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="韜の道" type="application/atom+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><div><img src="/medias/loading.gif" data-original="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">韜の道</span></div></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li><li><a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/loading.gif" data-original="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">韜の道</div><div class="logo-desc">Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/bearhao" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/bearhao" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(https://media6x.files.wordpress.com/2023/01/2.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Go Web 编程原理</h1></div></div></div></div></div><main class="post-container content"><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Go/"><span class="chip bg-color">Go</span> </a><a href="/tags/Web/"><span class="chip bg-color">Web</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Golang/" class="post-category">Golang</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2021-09-07</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 10.5k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 41 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><link rel="stylesheet" href="/libs/prism/prism.min.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre-wrap!important}</style><div class="card-content article-card-content"><div id="articleContent"><hr><h1 id="WEB-编程原理"><a class="header-anchor" href="#WEB-编程原理">¶</a>WEB 编程原理</h1><hr><hr><h3 id="Web-服务器的工作过程"><a class="header-anchor" href="#Web-服务器的工作过程">¶</a>Web 服务器的工作过程</h3><hr><p>一个 Web 服务器也被称为 HTTP 服务器，它通过 HTTP 协议与客户端进行通信。客户端与服务器之间的通信是非持久连接的，当服务器发送了应答后就与客户端断开连接，等待下一次请求。</p><blockquote><p>浏览器本身是一个客户端，根据用户输入的 URL ，浏览器首先会请求 DNS 服务器，通过 DNS 获取相应域名对应的 IP 。</p></blockquote><blockquote><p>通过 IP 地址找到 IP 对应的服务器后，建立 TCP 连接。</p></blockquote><blockquote><p>浏览器发送完 HTTP Request（请求）包，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回 HTTP Response（响应）包</p></blockquote><blockquote><p>客户端收到来自服务器的响应后开始渲染该 Response 包里的主体（body），客户端收到全部的内容后，断开与该服务器之间的TCP连接。</p></blockquote><hr><p><img src="/medias/loading.gif" data-original="https://tao7app.files.wordpress.com/2023/01/img_20230105_132934.jpg" alt="访问一个Web站点的过程"></p><p>访问一个 Web 站点的过程：</p><ul><li><p>客户端通过 TCP/IP 协议建立到服务器的 TCP 连接。</p></li><li><p>客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档。</p></li><li><p>服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端。</p></li><li><p>客户端与服务器断开，由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果。</p></li></ul><hr><h2 id="URI-URL-和-DNS-解析"><a class="header-anchor" href="#URI-URL-和-DNS-解析">¶</a>URI , URL 和 DNS 解析</h2><hr><h3 id="URI"><a class="header-anchor" href="#URI">¶</a><strong>URI</strong></h3><p>URI (Uniform Resource Identifier，统一资源标志符)，用来标识 Web 上每一种可用资源，例如： HTML 文档、图像、视频片段、程序等都由一个 URI 进行标识。</p><p>URI 通常由资源的命名机制，标准存放资源的主机名，资源自身的名称组成。</p><h3 id="URL"><a class="header-anchor" href="#URL">¶</a><strong>URL</strong></h3><p>URL（Uniform Resource Locator，统一资源定位符）用于描述一个网络上的资源，基本格式如下：</p><p><code>scheme://host[:port#]/path/.../[?query-string][#anchor]</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">scheme        // 指定低层使用的协议（例如：http, https, ftp）

host          // HTTP 服务器的 IP 地址或者域名

port          // HTTP 服务器的默认端口是 80（可以省略），如果使用了别的端口，必须指明，例如 http://cqupt.edu.cn:8080/
    
path       	  // 访问资源的路径
 
query-string  // 发送给 http 服务器的数据
 
anchor        // 锚<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Go 语言中，URL 结构体的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> URI <span class="token keyword">struct</span> <span class="token punctuation">{</span>
Scheme <span class="token builtin">string</span>     <span class="token comment">// 方案</span>
Opaque <span class="token builtin">string</span>     <span class="token comment">// 编码后的不透明数据</span>
User <span class="token operator">*</span>Userinfo    <span class="token comment">// 基本验证方式中 username 和 password 信息 </span>
Host <span class="token builtin">string</span>       <span class="token comment">// 主机字段请求头</span>
Path <span class="token builtin">string</span>       <span class="token comment">// 路径</span>
RawPath <span class="token builtin">string</span>
ForceQuery <span class="token builtin">bool</span> 
RawQuery <span class="token builtin">string</span>   <span class="token comment">// 查询字段</span>
Fragment <span class="token builtin">string</span>   <span class="token comment">// 分片字段 </span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DNS-解析"><a class="header-anchor" href="#DNS-解析">¶</a><strong>DNS 解析</strong></h3><p>DNS（Domain Name System）是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络，将主机名或域名转换为实际 IP 地址。</p><hr><p><img src="/medias/loading.gif" data-original="https://tao7app.files.wordpress.com/2023/01/img_20230105_132951.jpg" alt="DNS工作原理"></p><p>DNS 解析的整个过程：</p><hr><p><img src="/medias/loading.gif" data-original="https://tao7app.files.wordpress.com/2023/01/img_20230105_133012.jpg" alt="DNS解析的整个流程"></p><ol><li><p>在浏览器中输入 <code>www.qq.com</code> 域名，操作系统会先检查自己本地的 <code>hosts</code> 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。</p></li><li><p>如果 <code>hosts</code> 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p></li><li><p>如果 <code>hosts</code> 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器（本地 DNS 服务器），当此服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p></li><li><p>如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。</p></li><li><p>如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 “根 DNS 服务器”，“根 DNS 服务器”收到请求后会判断这个域名（.com）由谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP 。本地 DNS 服务器收到 IP 信息后，将会联系负责 <code>.com</code> 域的这台服务器。这台负责 <code>.com</code> 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 <code>.com</code> 域的下一级 DNS 服务器地址（<code>qq.com</code>）给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 <code>qq.com</code> 域服务器，重复上面的动作，进行查询，直至找到 <code>www.qq.com</code> 主机。</p></li><li><p>如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是否转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。</p></li></ol><p>通过上面的步骤，最后获取的是 IP 地址，就是浏览器最后发起请求的时候是基于 IP 来和服务器做信息交互的。</p><hr><h2 id="HTTP-协议详解"><a class="header-anchor" href="#HTTP-协议详解">¶</a>HTTP 协议详解</h2><hr><h3 id="HTTP-协议的基本概念"><a class="header-anchor" href="#HTTP-协议的基本概念">¶</a>HTTP 协议的基本概念</h3><p>超文本传输协议（HTTP）是分布式、协作的、超媒体信息系统的应用层协议。HTTP 是一种让 Web服务器与浏览器（客户端）通过 Internet 发送与接收数据的协议，它建立在 TCP 协议之上，一般采用 TCP 的 <code>80</code> 端口，是一个无状态的请求/响应协议。</p><p>在 HTTP 协议中，客户端总是通过建立一个连接与发送一个 HTTP 请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接，客户端与服务器端都可以提前中断一个连接。</p><h3 id="HTTP-请求"><a class="header-anchor" href="#HTTP-请求">¶</a>HTTP 请求</h3><p>客户端发送到服务器端的请求信息由请求行（Request Line），请求（Request Header），请求体（Request Body）组成。 header 和 body 之间有个空行。</p><ul><li>请求行</li></ul><p>请求行由请求方法，URI 、HTTP协议和协议版本组成。</p><table><thead><tr><th style="text-align:center">请求方法</th><th style="text-align:left">方法描述</th></tr></thead><tbody><tr><td style="text-align:center">GET</td><td style="text-align:left">请求页面，并返回页面内容</td></tr><tr><td style="text-align:center">HEAD</td><td style="text-align:left">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:left">大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td style="text-align:center">PUT</td><td style="text-align:left">从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:left">请求服务器删除指定的资源</td></tr><tr><td style="text-align:center">OPTIONS</td><td style="text-align:left">允许客户端查看服务器的性能</td></tr><tr><td style="text-align:center">CONNECT</td><td style="text-align:left">把服务器当作跳板，让服务器代替客户端访问其他网页</td></tr><tr><td style="text-align:center">TRACE</td><td style="text-align:left">回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><p>一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET、POST、PUT、DELETE 对应着对这个资源的查、改、增、删 4 个操作。</p><hr><p>GET 和 POST 的区别：</p><ol><li><p>GET 一般用于获取/查询资源信息，而 POST 一般用于更新资源信息。GET请求消息体为空，POST请求带有消息体。</p></li><li><p>GET 提交的数据会放在 URL 之后，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连，如<code>EditPosts.aspx?name=test1&amp;id=123456</code> 。POST 方法是把提交的数据放在 HTTP 包的 Body 中。</p></li><li><p>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。</p></li><li><p>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p></li></ol><hr><ul><li>请求头</li></ul><p>请求头包含服务器要使用的附加信息（Cookie 、 Referer 、 User-Agent等）。</p><table><thead><tr><th style="text-align:left">请求头</th><th style="text-align:left">示 例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">Accept: text/plain,text/html</td><td style="text-align:left">指定客户端能够接收的内容类型</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">Accept-Charset: iso-8859-5</td><td style="text-align:left">浏览器可以接受的字符编码集</td></tr><tr><td style="text-align:left">Accept-Encoding</td><td style="text-align:left">Accept-Encoding: compress,gzip</td><td style="text-align:left">指定浏览器可以支持的 Web 服务器返回内容压缩编码类型</td></tr><tr><td style="text-align:left">Accept-Language</td><td style="text-align:left">Accept-Language:en,zh</td><td style="text-align:left">浏览器可接受的语言</td></tr><tr><td style="text-align:left">Accept-Ranges</td><td style="text-align:left">Accept-Ranges: bytes</td><td style="text-align:left">可以请求网页实体的一个或者多个子范围字段</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">Authorization: BasicdbxhZGRpbjpvcGVuIHNIc2Ftyd=</td><td style="text-align:left">HTTP授权的授权证书</td></tr><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">Cache-Control:no-cache</td><td style="text-align:left">指定请求和响应遵循的缓存机制</td></tr><tr><td style="text-align:left">Connection</td><td style="text-align:left">Connection: close</td><td style="text-align:left">表示是否需要持久连接。（HTTP1.1默认进行持久连接）</td></tr><tr><td style="text-align:left">Cookie</td><td style="text-align:left">Cookie: $Version=1; Skin=new;</td><td style="text-align:left">在发送 HTTP 请求时，会把保存在该请求域名下的所有 cookie 值一起发送给 Web 服务器</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">Content-Length:348</td><td style="text-align:left">请求的内容长度</td></tr></tbody></table><ul><li>请求体</li></ul><p>请求体是指在 HTTP 请求中传输数据的实体，常用于 POST 、 PUT 等请求中。</p><h3 id="HTTP-响应"><a class="header-anchor" href="#HTTP-响应">¶</a>HTTP 响应</h3><p>HTTP 响应由服务器端返回给客户端，分为响应状态码（Response Status Code）,响应头（Response Header）和响应体（Response Body）。</p><ul><li>状态码</li></ul><p>状态码用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response 。 HTTP/1.1 协议中定义了 5 类状态码，状态码由三位数字组成，第一个数字定义了响应的类别。</p><p>常见状态码类型：</p><blockquote><ul><li>1XX 提示信息——表示请求已被成功接收，继续处理。</li><li>2XX 成功——表示请求已被成功接收，理解，接受。</li><li>3XX 重定向——要完成请求必须进行更进一步的处理。</li><li>4XX 客户端错误——请求有语法错误或请求无法实现。</li><li>5XX 服务器端错误——服务器未能实现合法的请求。</li></ul></blockquote><ul><li>响应头</li></ul><p>响应头包含服务器对请求的应答信息，如 Content-Type 、 Server 、 Set-Cookie 等。</p><table><thead><tr><th style="text-align:center">响应头</th><th style="text-align:left">说 明</th></tr></thead><tbody><tr><td style="text-align:center">Allow</td><td style="text-align:left">服务器支持哪些请求方法（如 GET、POST 等）</td></tr><tr><td style="text-align:center">Content-Encoding</td><td style="text-align:left">文档的编码（Encode）方法。只有在解码之后才可以得到用 Content-Type 头指定的内容类型。利用 gzip 压缩文档能够显著地减少 HTML 文档的下载时间</td></tr><tr><td style="text-align:center">Content-Length</td><td style="text-align:left">表示内容长度。只有当浏览器使用持久 HTTP 连接时才需要这个数据</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:left">表示后面的文档属于什么 MIME 类型</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:left">当前的 GMT 时间</td></tr><tr><td style="text-align:center">Expires</td><td style="text-align:left">应该在什么时候认为文档已经过期，从而不再缓存它</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:left">文档的最后改动时间。可以通过 If-Modified-Since 请求头提供一个日期，该请求将被视为一个有条件的 GET 请求。只有改动时间迟于指定时间的文档才会返回，否则返回一个 304（Not Modified）状态。</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:left">也可用setDateHeader()方法来设置</td></tr><tr><td style="text-align:center">Location</td><td style="text-align:left">表示客户端应该当到哪里去提取文档，通常不是直接设置的</td></tr><tr><td style="text-align:center">Refresh</td><td style="text-align:left">表示浏览器应该在多少时间之后刷新文档，以秒计</td></tr><tr><td style="text-align:center">Server</td><td style="text-align:left">服务器的名字</td></tr><tr><td style="text-align:center">Set-Cookie</td><td style="text-align:left">设置和页面关联的 Cookie</td></tr><tr><td style="text-align:center">WWW-Authenticate</td><td style="text-align:left">客户应该在 Authorization 头中提供的授权信息。在包含 401（Unauthorized）状态行的应答中这个信息是必需的</td></tr></tbody></table><ul><li>响应体</li></ul><p>响应体是 HTTP 请求返回的内容，响应的正文数据都在响应体中。</p><hr><h2 id="接收和处理-Go-Web-请求"><a class="header-anchor" href="#接收和处理-Go-Web-请求">¶</a>接收和处理 Go Web 请求</h2><hr><h3 id="Go-Web服务器工作流程"><a class="header-anchor" href="#Go-Web服务器工作流程">¶</a>Go Web服务器工作流程</h3><p>Go Web 服务器请求和响应的流程如下：</p><ul><li><p>客户端发送请求</p></li><li><p>服务器端的多路复用器收到请求</p></li><li><p>多路复用器根据请求的URL找到注册的处理器，将请求交由处理器处理</p></li><li><p>处理器执行程序逻辑，如果必要，则与数据库进行交互，得到处理结果</p></li><li><p>处理密调用模板引擎将指定的模板和上一步得到的结果渲染成客户端可识别的数据格式（通常是 HTML 格式）</p></li><li><p>服务器端将数据通过 HTTP 响应返回给客户端</p></li><li><p>客户端拿到数据，执行对应的操作（如渲染出来呈现给用户）</p></li></ul><hr><h3 id="接收请求"><a class="header-anchor" href="#接收请求">¶</a>接收请求</h3><ol><li><strong>ServeMux 和 DefultServeMux</strong></li></ol><p>多路复用器用于转发请求到处理器,会在映射中找出被请求 URL 最为匹配的URL射至相应的处理器。它然后调用与之相对应的处理器的 ServeHTTP 方法来处理请求。</p><p>DefaultServeMux 是 <code>net/http</code> 包中默认提供的一个多路复用器，其实质是 ServeMux 的一个实例，多路复用器的任务是——根据请求的 URL 将请求重定向到不同的处理器。如果用户没有为 Server 对象指定处理器，则服务器默认使用 DefaultServeMux 作为 ServeMux 结构体的实例 ServeMux 也是一个处理器，可以在需要时对其实仪实施处理器串联。默认的多路复用器 DefauliServeMux 其声明语句如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> DefaultServeMux <span class="token operator">=</span> <span class="token operator">&amp;</span>defaultServeMux
<span class="token keyword">var</span> defaultServeMux ServeMux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>HandleFunc() 函数用于为指定的 URL 注册一个处理器，HandleFunc() 处理器函数会在内部调用 DefaultServeMux 对象的对应方法，其内部实现如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span> <span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter <span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span>

DefaultServeMux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token punctuation">,</span> handler<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过上面的方法体可以看出，http.HandleFunc() 函数将处理器注册到多路复用器中。用默认多路复用器还可以指定多个处理器，其使用方法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"net/http"</span>
    
<span class="token comment">//定义多个处理器</span>
	se thanalel <span class="token keyword">struct</span><span class="token punctuation">(</span>j
<span class="token keyword">func</span> <span class="token punctuation">(</span>hl <span class="token operator">*</span>handlel<span class="token punctuation">)</span><span class="token function">serveHTTP</span><span class="token punctuation">(</span>w 				http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>f
	fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hi,handlel"</span><span class="token punctuation">)</span>
	<span class="token keyword">type</span> handle2 <span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>h2 <span class="token operator">*</span>handle2<span class="token punctuation">)</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hi,handle2"</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">1</span>
	handlel <span class="token operator">:=</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	handle2 <span class="token operator">:=</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//nil表明服务器使用默认的多路复用器DefaultServeMux</span>
	server<span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">Server</span><span class="token punctuation">(</span>
		Addr<span class="token punctuation">:</span> “<span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span><span class="token punctuation">:</span><span class="token number">8085</span>"<span class="token punctuation">,</span>
		Handler<span class="token punctuation">:</span> ngl<span class="token punctuation">,</span>
<span class="token comment">//hande()函数调用的是多路复用器的		</span>
	DefaultServeMux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法	
    http<span class="token punctuation">,</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/handlel"</span><span class="token punctuation">,</span>shandle1<span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/handle2"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle2<span class="token punctuation">)</span>
	server<span class="token punctuation">.</span><span class="token function">listenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，直接用 http.Handle() 函数来指定多个处理器。Handle() 函数的代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Handle <span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token function">Func</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> bandler<span class="token punctuation">)</span><span class="token punctuation">]</span> handler Handler<span class="token punctuation">)</span> 
DefaultServeMux<span class="token punctuation">.</span>Hardle<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过代码可以看到，在 http.Handle() 函数中调用了 DefaultServeMux.Handle() 方法来处理清求服 器收到的每个请求都会调用对应多路复用器的 ServeHTTP( 方法。该方法的代码详情如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> handler serverHandler<span class="token punctuation">)</span><span class="token function">SezveHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req Request<span class="token punctuation">)</span> <span class="token operator">:=</span>sh<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler
<span class="token keyword">if</span> handler sx <span class="token boolean">nil</span>
handler <span class="token operator">=</span> DefaultServeMux
handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> req<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 ServeMux 对象的 ServeHTTP()方法中，会根据 URL 查找注册的处理器，然后将请求交由它处理。<br>虽然默认的多路复用器使用起来很方便，但是在生产环境中不建议使用。因为 DefaultServeMux 是一个全局变量，所有代码（包括第三方代码）都可以修改它。有些第三方代码会在 DefaultServeMux 中注册一些处理器，这可能与注册的处理器冲突。比较推荐的做法是自定义多路复用器。<br>自定义多路复用器也比较简单，直接调用 http.NewServeMux() 函数即可。然后，在新创建的多路复用器上注册处理器；</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">mux <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewSeryeMux</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在上面代码中，创建了一个读超时和写超时均为5s的服务器。</p><p>简单总结一下 ServerMux 实现了 http.Handler 接口的 ServeHTTP(ResponseWriter.*Request) 方法。在创建 Server 时，如果设置 Handler 为空，则使用 DefaultServeMux 作为默认的处理器，而 DefaultServeMux 是 ServerMux 的一个全局变量。</p><ol start="2"><li><strong>ServeMux 的 URL 路由匹配</strong></li></ol><p>在实际应用中，一个 Web 服务器往往有很多的 URL 绑定，不同的URL对应不同的处理器。服务器是决定使用哪个处理器过程：<br>假如现在绑定了 3 个 URL，分别是 /、/hi 和 /hi/web ：</p><ul><li>如果请求的 URL为 /，则调用 / 对应的处理器</li><li>如果请求的 URL 为 /hi ，则调用 /hi 对应的处理器</li><li>如果请求的 URL 为 /hi/web ，则调用 /hi/web 对应的处理器。</li></ul><ol start="3"><li><strong>处理器</strong></li></ol><p>服务路在收到请求后，会根据其 URL 将请求交给相应的多路复用器，多路复用器将请求转发给处理器处理。处理器是实现了 Handler 接口的结构。Handler 接口被定义在 <code>net/http</code> 包中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span><span class="token punctuation">(</span>
<span class="token keyword">func</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>wResponse<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> r<span class="token operator">*</span>Request<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到，Handler 接口中只有一个 ServeHTTP() 处理器方法。任何实现了 Handle 接口的对象，都可以被注册到多路复用器。</p><ol start="4"><li><strong>处理器函数</strong></li></ol><p>下面以默认的处理器函数 HandleFunc() 为例介绍处理器的使用方法。</p><ul><li>注册一个处理器函数</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> func_name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个处理器函数的第 1 个参数表示匹配的路由地址 第 2 个参数表示一个名为 func_name 的方法，用于处理具体业务逻辑。例如，注册一个处理器函数，并将处理器的路由匹配到 hi 函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>hi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>定义一个名为 hi 的函数，用来打印一个字符串到浏览器：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hi</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hi Web!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>net/http</code> 包提供了以函数的方式注册处理器，即用HandleFunc() 函数来注册处理器，如果一个函数实现了匿多函数 func(w http.ResponseWriter,r *http.Request) ，则这个函数被为为“处理器函数”。 HandleFunc() 函数内部调用了 ServeMux 对象的 Handlefunc() 方法。ServeMux 对象的 HandleFunc() 方法具体代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">m Haudlet
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> Hand1eFunc <span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span> <span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Reguest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>
<span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">(</span>
panichttpiil hanale居历ihHamaler
mux<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token function">HandlerFunc</span><span class="token punctuation">(</span>handlex<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续查看内部代码可以发现 HandlerFunc( 函数最终也实现了 Handler 接口的 ServeHTTP() 方法。其实现代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span>ServeHTTP <span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span>
<span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>Handler:处理器接口。定义在 <code>net/http</code> 包中，实现了 Handler 接口的对象，可以生到多路复用器中。</li><li>Handle()：注册处理器过程中的调用函数。</li><li>HandleFunc()：处理器函数。</li><li>HandlerFunc:底层为 func (w ResponseWriter,r*Request) 匿名函数，实现了 Handler 处理器接口。它用来连接处理器函数与处理器。<br>简而言之 HandlerFunc() 是一个处理器函数，其内部通过对 ServeMux 中一系列方法的调用最终在底层实现了 Handler 处理器接口的 SepveHTTP) 方法，从而实现处理器的功能。</li></ol><h3 id="处理请求"><a class="header-anchor" href="#处理请求">¶</a>处理请求</h3><ol><li><strong>Request</strong></li></ol><p>Request 是 http 请求，用于返回 HTTP 请求的报文，里面包含了浏览器端的相关信息。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">{</span>
Method <span class="token builtin">string</span> <span class="token comment">//请求的方法</span>
URL <span class="token operator">*</span>url<span class="token punctuation">.</span>URL <span class="token comment">//请求报文中的 URL 地址，是指针类型Proto string //形如："HTTP/1.0”</span>
ProtoMajorint <span class="token comment">//1</span>
ProtoMinorint <span class="token comment">//0</span>
Header Header <span class="token comment">// 请求头字段</span>
Bodyio<span class="token punctuation">.</span>ReadCloser <span class="token comment">// 请求体</span>
GetBody <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
ContentLength <span class="token builtin">int64</span>
TransferEncoding <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token comment">//</span>
Close <span class="token builtin">bool</span>
Host <span class="token builtin">string</span>
请求报文中的一些参数，包括表单字段等
Form url<span class="token punctuation">.</span>Values
PostForm url<span class="token punctuation">.</span>Values
MultipartForm <span class="token operator">*</span>multipart<span class="token punctuation">.</span>Form
Trailer Header
RemoteAddr <span class="token builtin">string</span>
RequestURI <span class="token builtin">string</span>
TLS <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionState
Cancel <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
Response <span class="token operator">*</span>Response
ctx context<span class="token punctuation">.</span>Context
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Reauest 结构体主要用于返回.话同的应，只有正确也解行真越数屏、才能内客户端返回响应。接下来通过简单示例来测过一下。下方是 Go 服务器端的代码，用于解析 Request 结构体中各成员(或者说是属性)。代码:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span>（
<span class="token string">"fmt"</span>
<span class="token string">"log"</span>
<span class="token string">"net/http"</span>
<span class="token string">"strings"</span>
<span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">(</span>
<span class="token comment">//这些信息是输出到服务器端的打印信息</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Request解析"</span><span class="token punctuation">)</span>
<span class="token comment">//HTTP方法</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"method"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Method<span class="token punctuation">)</span>
<span class="token comment">//RequestURI是被客户端发送到服务器端的请求行中未修改的请求</span>
URIfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"RequestURI:"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>RequestURI<span class="token punctuation">)</span>
<span class="token comment">//URL 类型，下方分别列出URL的各成员</span>
fnt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL_path"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
fnt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL RawQuery"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>RawQuery<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"URL_Fragment"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Fragment<span class="token punctuation">)</span>
<span class="token comment">//协议版本</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"proto"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>Proto<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"protomajor"</span><span class="token punctuation">,</span>r<span class="token punctuation">.</span>ProtoMajor<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"protominor"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ProtoMinor<span class="token punctuation">)</span>
<span class="token comment">//HTTP请求头</span>
<span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>Header一
<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> vv <span class="token operator">:=</span> <span class="token keyword">range</span> v <span class="token punctuation">(</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"header key:"</span><span class="token operator">+</span> k<span class="token operator">+</span><span class="token string">"value:"</span><span class="token operator">+</span> vv<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token comment">//判断是否为multipart方式</span>
isMultipart<span class="token operator">:=</span> <span class="token boolean">false</span>
<span class="token keyword">for</span> <span class="token punctuation">,</span> v<span class="token operator">:=</span><span class="token keyword">range</span> r<span class="token punctuation">.</span>Header<span class="token punctuation">[</span><span class="token string">"Content-Type"</span><span class="token punctuation">]</span><span class="token punctuation">(</span>
<span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token string">"multipart/form-data"</span><span class="token punctuation">)</span> ！<span class="token operator">=</span><span class="token operator">-</span><span class="token function">1</span><span class="token punctuation">(</span>isMultipart <span class="token operator">=</span><span class="token boolean">true</span>
<span class="token punctuation">)</span><span class="token punctuation">(</span>解析 Form表单
<span class="token keyword">if</span> isMultipart <span class="token operator">==</span> <span class="token boolean">true</span> 
r<span class="token punctuation">.</span><span class="token function">ParseMultipartForm</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"解析方式:ParseMultipartForm"</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">else</span> （
r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"解析方式：ParseForm"</span><span class="token punctuation">)</span>
<span class="token comment">//HTTP Body 内容长度</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ContentLength"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>ContentLength<span class="token punctuation">)</span>
<span class="token comment">//是否在回复请求后关闭连接</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Close"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>Close<span class="token punctuation">)</span>
<span class="token comment">//HOST</span>
fmt<span class="token punctuation">.</span>Prin host"<span class="token punctuation">,</span>r<span class="token punctuation">.</span>Host<span class="token punctuation">)</span>
<span class="token comment">//该请求的来源地班</span>
fmt<span class="token punctuation">.</span><span class="token function">PrintIn</span><span class="token punctuation">(</span><span class="token string">"RemoteAddr"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>RemoteAddr<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"hello, let's go!"</span><span class="token punctuation">)</span> <span class="token comment">//这个是输出到客户端的</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span>request<span class="token punctuation">)</span>
err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8081"</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err<span class="token operator">!=</span><span class="token boolean">nil</span> 
log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"ListenAndServe:"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请求头和响应头使用 Header 类型表示。Header 类型是一个映射(map)类型，表示 HTTP 请求头中的多个键值对。其定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Header <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过请求对象的 Header 属性可以访问到请求头信息。Header 属性是映射结构，提供了 Get() 方法以获取 key 对应的第一个值。Get() 方法的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Header 结构体的其他常用方法的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span><span class="token function">Set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// 设置头信息</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span><span class="token function">Add</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">//添加头信息</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Del</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">//删除头信息</span>

<span class="token keyword">func</span><span class="token punctuation">(</span>h Header<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>w io<span class="token punctuation">.</span>Writer<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token comment">//使用线模式(in wire format)写头信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请求体和响应体都由 Request 结构中的 Body 字段表示。 Body 字段是一个 <code>io.ReadCloser</code> 接口。<code>ReadCloser</code> 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ReadCloser <span class="token keyword">interface</span> <span class="token punctuation">{</span>
Reader
Closer
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Body 字段是 <code>Reader</code> 接口和 <code>Closer</code> 接口的结<br>合。<code>Reader</code> 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">{</span>
<span class="token function">Read</span><span class="token punctuation">(</span>P <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过 Reader 接口可以看到，Read() 方法实现了 ReadCloser 接口。所以，可以通过 Body.Read() 方法来读取请求体信息接下来通过示例来加深对 Body.Read() 方法的理解。</p><ul><li><strong>Response</strong></li></ul><p>Response 是 http 请求的响应，包含返回给浏览器端的数据。</p><p>共结构体定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Response <span class="token keyword">struct</span> <span class="token punctuation">{</span>
Status <span class="token builtin">string</span> <span class="token comment">// e.g. "200OK"</span>
StatusCode <span class="token builtin">int</span> <span class="token comment">// e.g. 200</span>
Proto <span class="token builtin">string</span> <span class="token comment">// e.g. "HTTP/1.0"</span>
ProtoMajor <span class="token builtin">int</span> <span class="token comment">// e.g. 1</span>
ProtoMinor <span class="token builtin">int</span> e<span class="token punctuation">.</span>g<span class="token punctuation">.</span> <span class="token number">0</span>
Header Header
Body io<span class="token punctuation">.</span>ReadCloser
ContentLength <span class="token builtin">int64</span>
TransferEncoding<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
Close <span class="token builtin">bool</span>
Uncompressed <span class="token builtin">bool</span>
Trailer Header
Request <span class="token operator">*</span>Request
TLS <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionState
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>ResponseWriter 原理</strong></li></ol><p>Co 语言对接口的实现，不需要显式的声明，只要实迎了被口定义的方法，那就实现了相应的接口。<br><code>io.Wrter</code> 是一个接口类型。如果要使用 <code>io.Writer</code> 接口的 Write() 方法，则需要实现 Wrte([]byte) (n int, err error) 方法。<br>在 Go 语言中，客户端请求信息都被封装在 Request 对象中。但是发送给客户端的响应并不是 Response 对象，而是 ResponseWriter 接口。ResponseWriter 接口是处理器用来创建 HTTP 响应的接口的。ResponseWriter 接口的定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ResponseWriter <span class="token keyword">interface</span> 
<span class="token operator">/</span><span class="token number">1</span> 用于设置或者获取所有响应头信息
Header <span class="token punctuation">(</span><span class="token punctuation">)</span> Header
<span class="token comment">// 用于写入数据到响应体中</span>
<span class="token function">Write</span><span class="token punctuation">(</span>lJbyte<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token operator">/</span><span class="token number">1</span> 用于设置响应状态码
<span class="token function">WriteHeader</span><span class="token punctuation">(</span>statusCode <span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，在底层支撑 ResponseWriter 接口的是http.response 结构体。在调用处理器处理 HTTP 请求时，会调用 readRequest() 方法 readRequest() 方法会声明response结构体，并且其返回值是 response 指针这也是在处理器方法声明时，Reqyest 是指针类型，而 ResponseWriter 不是指针类型的原因。实际上，响应对象也是指针类型。<br>核心代码如下： readRequest()方法的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">readRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token comment">//此处省略若干代码</span>
w<span class="token operator">=</span> <span class="token operator">&amp;</span>responsef 走明
C<span class="token punctuation">.</span>
conn<span class="token punctuation">:</span>
cancelCtx<span class="token punctuation">:</span> cancelCtx<span class="token punctuation">,</span>
req<span class="token punctuation">:</span> req<span class="token punctuation">,</span>
regBody<span class="token punctuation">:</span> req<span class="token punctuation">.</span>Body<span class="token punctuation">,</span>
handlerHeader<span class="token punctuation">:</span><span class="token builtin">make</span> <span class="token punctuation">(</span>Header<span class="token punctuation">)</span><span class="token punctuation">,</span>
contentLength<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
closeNotifyCh<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
wants10KeepAlive<span class="token punctuation">:</span> req<span class="token punctuation">.</span><span class="token function">wantsHttp10KeepAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
wantsClose<span class="token punctuation">:</span> req<span class="token punctuation">.</span><span class="token function">wantsClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">if</span> isH2Upgradef
w<span class="token punctuation">.</span>closeAfterReply <span class="token operator">=</span> <span class="token boolean">true</span>
w<span class="token punctuation">.</span>cw<span class="token punctuation">.</span>res <span class="token operator">=</span>w
w<span class="token punctuation">.</span>w <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>w<span class="token punctuation">.</span>cw<span class="token punctuation">,</span> bufferBeforeChunkingSize<span class="token punctuation">)</span>
<span class="token keyword">return</span> w<span class="token punctuation">,</span> <span class="token boolean">nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>response 结构体的定义和 ResponseWriter 接口都位于 server.go 文件中。不过由于 response 结构体是私有的，对外不可见，所以只能通过 ResponseWriter 接口访问它。两者之间的关系是：ResponseWriter 是一个接口，而 response 结构体实现了。我们引用 ResponseWriter 接口，实际上引用的是 response 结构体的实例。</p><p>ResponseWriter 接口包含 WriteHeader()、Header()、Write() 三个方法来设置响应状态码。</p><ul><li><p>WriteHeader() 方法<br>WrteHeader()方法支持传入一个整型数据来表示响应状态码。如果不调用该方法，则默认响应状态码是200。 WriteHeader() 方法的主要作用是在 API 接口中返回错误码。例如，可以自定义一个处理器方法 noAuth()，并通过w.WriteHeader()方法返回一个401未认证状态码(注意，在运行时，w代表的是对应的response对象实例，而不是接口)。</p></li><li><p>Header()方法<br>Header()方法用于设置响应头。可以通过wHeader().Set()方法设置响应头。w.Header()方法返回的是Header 响应头对象，它和请求头共用一个结构体。因此在请求头中支持的方法这里都支持，比如可以通过w.Header().Add(方法新增响应头。<br>例如，如果要设置一个301重定向响应，则只需要通过w.WriteHeader()方法将响应状态码设置为301，再通过w.Header().Set()方法将“Location”设置为一个可访问域名即可。</p></li></ul><p>提示<br>w.Header(.Set(方法应在 w.WriteHeader(方法之前被调用，因为一旦调用了w.WriteHeaderO方法，就不能对响应头进行设置了。</p><ul><li>Wite() 方法<br>Write() 方法用于将数据写入 HTTP 响应体中。如果在调用Write() 方法时还不知道 Coment-Te 真型，则可以通过数据的前512个 byte 进行判断。用 Write()方法可以返回字符毫数据也可以返回 HTML 文档和 JSON 等常见的文本格式。</li></ul><ul><li>Conn</li></ul><p>Conn是http的请求连接。</p><ul><li>Handler</li></ul><p>Handler是接收请求后逻辑处理和生成返回信息的逻辑。</p><hr><h2 id="http包运行机制"><a class="header-anchor" href="#http包运行机制">¶</a>http包运行机制</h2><hr><p>1.创建Listen Socket，监听指定的端口，等待客户端请求到来。<br>2.Listen Socket接受客户端的请求, 得到Client Socket，接下来通过Client Socket与客户端通信。<br>3.处理客户端的请求，首先从Client Socket读取HTTP请求的协议头，如果是POST方法，还可能要读取客户端提交的数据，然后交给相应的handler处理请求，handler处理完毕准备好客户端需要的数据，通过Client Socket写给客户端。</p><hr><p><img src="/medias/loading.gif" data-original="https://tao7app.files.wordpress.com/2023/01/img_20230105_133058.jpg" alt="Go语言中http包的运行示意图"></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1.</span> <span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token punctuation">{</span>
<span class="token number">2.</span><span class="token keyword">defer</span> <span class="token number">1.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">3.</span> <span class="token keyword">var</span> tempDelay time<span class="token punctuation">.</span>Duration<span class="token comment">// how long to sleep on accept failure</span>
<span class="token number">4.</span> <span class="token keyword">for</span><span class="token punctuation">{</span>
<span class="token number">5.</span> rw<span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token number">1.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">6.</span> <span class="token keyword">if</span> e ！<span class="token operator">=</span><span class="token boolean">nil</span> <span class="token punctuation">(</span>
<span class="token number">7.</span> <span class="token keyword">if</span> ne<span class="token punctuation">,</span> ok <span class="token operator">:=</span> e<span class="token punctuation">.</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> ne<span class="token punctuation">.</span><span class="token function">Temporary</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token number">8.</span><span class="token keyword">if</span>
 tempDelay<span class="token operator">=</span><span class="token number">5</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Millisecond
<span class="token punctuation">)</span><span class="token keyword">else</span> <span class="token punctuation">(</span>
<span class="token number">10.</span> tempDelay<span class="token operator">*=</span><span class="token number">2</span>
<span class="token number">11.</span> <span class="token punctuation">)</span>
time<span class="token punctuation">.</span>Second<span class="token punctuation">;</span> tempDelay <span class="token operator">&gt;</span> max
：<span class="token operator">=</span><span class="token number">1</span>
<span class="token number">12.</span> <span class="token number">13.</span> <span class="token keyword">if</span> max tempDelay <span class="token operator">=</span> max 【
<span class="token number">14.</span> <span class="token punctuation">)</span>
<span class="token number">15.</span> log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"http: Accept error: 8v; retrying in Bv"</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> tempDelay<span class="token punctuation">)</span>
<span class="token number">16.</span> time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>tempDelay<span class="token punctuation">)</span>
<span class="token number">17.</span> <span class="token keyword">continue</span>
<span class="token number">18.</span>
<span class="token number">19.</span> <span class="token keyword">return</span> e
<span class="token number">21.</span> <span class="token number">20.</span> tempDelay <span class="token operator">=</span><span class="token number">0</span>
<span class="token number">22.</span>
<span class="token number">23.</span> c<span class="token punctuation">,</span> err：<span class="token operator">=</span>srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span><span class="token boolean">nil</span> <span class="token punctuation">(</span>
<span class="token number">24.</span>
<span class="token keyword">continue</span>
<span class="token number">25.</span>
<span class="token number">26.</span>
<span class="token number">27.</span> <span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">28.</span> <span class="token punctuation">}</span>
<span class="token number">29.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过这段源码可以看到 Go 语言对于整个 http 请求的处理过程。<br>Server的Serve(l net.Listener)方法就是用于监听和处理http请求的。从第4行开始，函数中就开始了一个for循环，第5行通过参数Listener的Accept接收请求，然后在第23行基于接收的信息新建一个Conn，最后第27行启动一个goroutine来单独为一个Conn服务，不影响其他的Conn是并发的体现。</p><p>整个的过程中，我们只要了解清楚下面三个问题，也就知道Go语言是如何让Web运行起来了。</p><p>● 如何监听端口？● 如何接收客户端请求？● 如何分配handler？从前面小节的代码里面我们可以看到，Go 语言是通过一个函数来操作这个事情的ListenAndServe来监听的，这个底层其实这样处理的：初始化一个server对象，调用net. Listen(“tcp”, addr)，也就是底层用TCP协议搭建了一个服务，然后监控我们设置的端口。<br>监控之后如何接收客户端的请求呢？上面代码执行监控端口之后，调用了srv.Serve(net.Listener)函数，这个函数就是处理接收客户端的请求信息。这个函数里面起了一个 for{}，首先通过 Listener 接收请求，其次创建一个 Conn，最后单独开了一个goroutine，把这个请求的数据当做参数扔给这个conn去服务：go c.serve()。即成高并发体现，用户的每一次请求都是在一个新的goroutine去服务，相互不影响。<br>那么如何具体分配到相应的函数来处理请求呢？conn 首先会解析request:c.readRequest()，然后获取相应的handler:handler := c.server.Handler，也就是我们刚才在调用函数 ListenAndServe 时候的第二个参数，我们前面例子传递的是 nil，也就是为空，默认获取handler = DefaultServeMux，那么用这个变量做什么的呢？对，这个变量就是一个路由器，它用来匹配url跳转到其相应的handle函数。我们调用的代码里面第一句就调用了http.HandleFunc(“/”, sayhelloName)。这个作用就是注册了请求/的路由规则，当请求 uri 为"/"，路由就会转到函数 sayhelloName，DefaultServeMux 会调用ServeHTTP方法，这个方法内部其实就是调用sayhelloName本身，最后通过写入response的信息反馈到客户端。详细的流程如图3.10所示。</p><p><img src="/medias/loading.gif" data-original="https://tao7app.files.wordpress.com/2023/01/weread_image_87940054354055.jpeg" alt=""></p><p>至此，三个问题已经全部得到了解答，你现在对于Go语言如何让Web跑起来是否已经有基本了解？</p><hr><h2 id="Go语言的http包详解"><a class="header-anchor" href="#Go语言的http包详解">¶</a>Go语言的http包详解</h2><hr><ol><li><strong>Handler</strong></li></ol><p>net/http包的Handle和HandleFunc这两个函数的作用。这两个函数都是接收两个参数：第一个参数都是pattern(请求路径)，因为其效果都是给路径绑定处理函数，所以两个函数的作用是一样的；对于第二个参数，一个是Handler接口类型，也就是说只要实现了该接口的函数都可以作为第二个参数传人；另一个则是以函数类型作为参数，只要传入的函数以func(http.ResponseWriter，*http.Request)形式声明就可以。因为ServeHttp的声明满足HandleFunc第二个参数的要求，所以上面代码中第6行可以改为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">th <span class="token operator">:=</span> <span class="token function">ThisHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span>th<span class="token punctuation">.</span>ServeHttp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>虽然上面的两个函数在使用的时候有些区别，但是对于Co语言的底层实现来说并无二.，都是交给DcfaultServeMux来完成处理函数和路由的绑定。</p><ol start="3"><li><strong>ServerMux</strong></li></ol><p>DefualtSeveMux也提供了DefaultServeMux handle和DefaulterveMux handleFunc这两个函数。可用它们把http Handle和http.andleFunc的patern和Handler函数绑定到ServerMux上。DefaultServeMux是ServerMux的实例对象，下面来看一下ServerMux的结构体定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span><span class="token punctuation">(</span>
mu sync<span class="token punctuation">.</span>RWMutex<span class="token comment">// 读写锁</span>
m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry<span class="token comment">//路由 map, pattern-&gt;HandleFunc</span>
hosts <span class="token builtin">bool</span><span class="token comment">// 是否包含 hosts</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span><span class="token punctuation">(</span>
explicit <span class="token builtin">bool</span><span class="token comment">//是否精确匹配，http包内都使用ture</span>
h Handler <span class="token comment">// 路由对应的Handler</span>
pattern <span class="token builtin">string</span><span class="token comment">// 路由</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的路由和handler的绑定最终都存储到这里。因为http包内仅支持精确匹配，所以使用标准的net/http包不能直接配置带参数的路由，只能配置参数前面的路径，然后在handler内部再处理。也可以借助第三方包，比如httprouter。</p><ol start="3"><li><strong>Server</strong></li></ol><p>在配置好路由、处理函数以后，接下来就要启动服务，可使用如下代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span>"<span class="token punctuation">:</span><span class="token number">8080</span>°<span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数是监听的端口，以字符串的形式传递；第二个参数是handler，传入的是il该语句执行完毕后就开始监听8080端口，来看一下该函数的源码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">LiatenAndserve</span><span class="token punctuation">(</span>addrstringrhandler Handler<span class="token punctuation">)</span><span class="token builtin">error</span><span class="token punctuation">[</span>
server te <span class="token function">aServer</span><span class="token punctuation">(</span>Addr<span class="token punctuation">:</span>addr<span class="token punctuation">:</span>Handler<span class="token punctuation">:</span> handler<span class="token punctuation">)</span>
<span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出，该方法首先要做的就是创建 Server 的实例，并且调用其 ListenAndServe方。可见Server非常重要，下面来看一下Server的结构体：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1.</span> <span class="token keyword">type</span> Server atruct监听的地址和婚口
Addr <span class="token builtin">string</span>
<span class="token number">3.</span> <span class="token number">2.</span> Bandler Bandler <span class="token comment">// handlerto invoke, http.DefaultServeMuxif nil</span>
TLSContig<span class="token operator">*</span>tls<span class="token punctuation">.</span>Config <span class="token operator">/</span><span class="token number">1</span> 读超时时间
<span class="token number">5.</span> ieadTineouttime<span class="token punctuation">.</span>Duration
time<span class="token punctuation">.</span>Doration <span class="token comment">// 读关文件超时时间</span>
<span class="token number">6.</span> ReadieaderTineout
<span class="token number">7.</span> writeTimeouttime<span class="token punctuation">.</span>Duration <span class="token comment">//写超时时间</span>
<span class="token number">8.</span> IdleTimoout time<span class="token punctuation">.</span>Duration
<span class="token number">9.</span> HaxlleaderBytesint
<span class="token number">10.</span> TLSNextProtonap<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token operator">*</span>tls<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> Handler<span class="token punctuation">)</span>
<span class="token number">12.</span> ConnState <span class="token keyword">func</span> <span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> ConnState<span class="token punctuation">)</span>
<span class="token number">12.</span> ErrorLog ·log<span class="token punctuation">.</span>Logger
<span class="token number">13.</span>
<span class="token number">14.</span> BaseContextfunc <span class="token punctuation">(</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context
ConnContext <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> context<span class="token punctuation">.</span>Context
<span class="token number">25.</span>
<span class="token number">16.</span> disableKeepAlivesint32 accessed atomically<span class="token punctuation">.</span>
<span class="token number">17.</span> inShut<span class="token punctuation">.</span>dowm <span class="token builtin">int</span> <span class="token number">32</span> accessedatomically <span class="token punctuation">(</span>non<span class="token operator">-</span>zero means we're in
<span class="token number">18.</span>
<span class="token number">19.</span> nextProtoonce sync<span class="token punctuation">.</span>Once <span class="token comment">// guards setupHTTP2</span>
init
<span class="token number">11</span> http2<span class="token punctuation">.</span>ConfigureServerShutdown<span class="token punctuation">)</span>
<span class="token number">20.</span> nextProtoErr erTor result of <span class="token keyword">if</span> used
<span class="token number">21.</span> mu sync<span class="token punctuation">,</span>Mutex
<span class="token number">22.</span>
<span class="token number">23.</span> 1isteners <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token operator">*</span>net<span class="token punctuation">.</span>Listener<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">24.</span> activeConn
doneChan <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token operator">*</span>conn<span class="token punctuation">)</span><span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">25.</span> onShutdownchan
<span class="token punctuation">(</span><span class="token function">lfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">26.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看一下Server的三个方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span>

<span class="token keyword">func</span><span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">func</span><span class="token punctuation">(</span>srv<span class="token operator">*</span>Server<span class="token punctuation">)</span><span class="token function">ListenAndServeTLS</span><span class="token punctuation">(</span>certFile<span class="token punctuation">,</span> keyFile <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中Serve方法在9.1.1节已经详细介绍过，此处不再赘述。<br>ListenAndServe方法的作用是开启http Server服务。ListenAndServeTLS方法的作用是开启https Server服务。</p><p>RespomseWriter:生成 Response的接口。<br>ServerMux：路由处理函数，这个刚刚介绍过。<br>在Serve方法执行完成后，就执行Conn(连接)的Serve方法，然后再通过Conn的readRequest方法获取Response。从逻辑上来说，c.serve方法就是完成这个功能的，此处我们需关注以下三个接口。</p><p>(1)ResponseWriter接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ResponseWriter <span class="token keyword">interface</span>
<span class="token comment">// Beader 方法返回 Response 返回的 Header 供读写</span>
Header <span class="token punctuation">(</span><span class="token punctuation">)</span> Header
<span class="token comment">// Write 方法写 Response 的 Body</span>
<span class="token function">Write</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token comment">// WriteHeader 方法根据 HTTP状态码来写 Response的Header</span>
<span class="token function">WriteHeader</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该接口的主要作用是供Handler函数调用，用来生成要返回的Response。<br>(2)Flusher接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Flusher <span class="token keyword">interface</span> t
<span class="token number">1</span><span class="token operator">/</span>刷新缓存区
Cotter <span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该接口的主要作用是供Handler调用，将写缓存中的数据刷新到客户端。<br>(3)Hijacker接口</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Hijacker <span class="token keyword">interface</span> <span class="token punctuation">(</span>
<span class="token punctuation">)</span> Hijacker <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>net<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> <span class="token operator">*</span>bufio<span class="token punctuation">.</span>ReadWriter<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该接口的主要作用是供Handler调用，用以关闭连接。<br>以上是Handler在执行过程中最常用、最重要的三个接口，正是这三个接口使Handler可以在处理完逻辑后把结果写回客户端，稍后会介绍实现这三个接口的对象。<br>通过对Server的介绍，读者可以知道如何在接受请求后调用Handler并且生成response。 response生成以后数据是如何写到客户端的呢？接下来我们开始了解response。<br>4.response<br>下面的方法用于把数据写给客户端：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">serverHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Server<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>w<span class="token punctuation">.</span>req<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该语句最终触发了路由绑定，w是response的实例对象(此处的w是ResponseWriter接口)，response实现了 ResponseWriter、Flusher、Hijacker接口。<br>来看一下response结构体的定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1.</span> <span class="token keyword">type</span> response <span class="token keyword">struct</span>
conn <span class="token operator">*</span>conn <span class="token comment">//保存此次HTTP连接的信息</span>
<span class="token comment">//对应请求信息</span>
<span class="token operator">*</span>Request
<span class="token number">4.</span> <span class="token number">2.</span> <span class="token number">3.</span> reg
chunking <span class="token builtin">bool</span> <span class="token comment">//是否使用chunk</span>
<span class="token number">5.</span> wroteHeaderbool <span class="token comment">// header是否已经执行过写操作</span>
<span class="token number">6.</span> wroteContinuebool <span class="token comment">//100 Continue response was written</span>
<span class="token number">7.</span> header Header <span class="token operator">/</span> <span class="token operator">/</span> 返回的 HTTP的Header
<span class="token number">8.</span> written <span class="token builtin">int64</span> <span class="token comment">// Body的字节数</span>
<span class="token number">9.</span> contentLength <span class="token builtin">int64</span> <span class="token comment">// Content 长度</span>
HTTP状态
<span class="token number">10.</span>
status
<span class="token comment">//</span>
<span class="token number">11.</span> needSniffboolint
<span class="token number">1</span><span class="token operator">/</span>是否开启sniff。若不设置Content<span class="token operator">-</span>Type，开启sniff能自动确定Content<span class="token operator">-</span>Type <span class="token operator">/</span><span class="token number">1</span> 是否保持长链接。若request有keep<span class="token operator">-</span>alive，该字
<span class="token number">12.</span> closeAfterReplybool
段就设置为<span class="token boolean">false</span>。 是否requestBody太大。当requestBody太大时，
<span class="token number">13.</span> requestBodyLimitHitbool <span class="token comment">//</span>
response 返回 <span class="token number">411</span>
<span class="token number">14.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器端需要返回给客户端的所有信息都包含在response中。<br>再来看一下response的主要方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Header
<span class="token keyword">func</span><span class="token punctuation">(</span>w<span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>code <span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token keyword">func</span><span class="token punctuation">(</span>w<span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">Write</span><span class="token punctuation">(</span>data <span class="token punctuation">(</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token keyword">func</span><span class="token punctuation">(</span>w<span class="token operator">*</span>response<span class="token punctuation">)</span><span class="token function">WriteString</span><span class="token punctuation">(</span>data <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token comment">// either dataB or dataS is non-zero.</span>
<span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">write</span><span class="token punctuation">(</span>lenDataint<span class="token punctuation">,</span> dataB <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> dataS <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">finishRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">func</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">)</span> <span class="token function">Hijack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>rwcnet<span class="token punctuation">.</span>Conn<span class="token punctuation">,</span> buf <span class="token operator">*</span>bufio<span class="token punctuation">.</span>ReadWriter<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，response确实实现了ResponseWriter、Flusher、Hijacker三个接口，有了这三个接口，response就可以把处理结果写回客户端。</p><ol start="5"><li>ServeHTTP(w,w.req)<br>前面介绍了如何通过 response把数据写回客户端，不过Handler如何生成response目前还没有介绍，其实非常简单，来看Handler接口：</li></ol><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span><span class="token punctuation">(</span>
<span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>具体的逻辑函数<br>在实现Handler接口的时候，就意味着已经有处理请求逻辑的函数了。serverHandle通过ServeHTTP来选择触发HandleFunc，此处有一个判断，如果有自定义的Handler函数就调用自己的，如果是nil则使用默认的DefaultServeMux。下面来梳理这个流程。<br>DefaultServeMux.ServeHttp的执行流程如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">i<span class="token punctuation">.</span> h<span class="token punctuation">,</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
ii<span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>者对这些内容的理解，此处再从执行流程上梳理一下，整体流程如下。<br>第一步：调用http.HandleFunc注册路由和对应处理函数。<br>第二步：先后调用DefaultServeMux的HandleFunc和Handle，并且向handler(也就是map[string]muxEntry)中注册路由和对象的函数。<br>第三步：实例化 Server，并调用ListenAndServe。<br>第四步：调用net.Listen(“tcp”，addr)，等待请求，每一个请求创建一个Conm，并且启动一个goroutine处理请求。<br>第五步：通过readRequest方法读取请求内容，或者说response的取值过程。<br>第六步：进入serveHandler.ServeHTTP，ServeHTTP方法内会判断有没有自定义的handler，如果没有则使用默认的DefaultServeMux。<br>第七步：调用handler(或DefaultServeMux)的ServeHTTP方法。<br>第八步：通过request选择匹配的handler，遍历muxEntry，寻找满足这个Request的路由。如果找到满足条件的路由，调用对象handler的ServeHTTP；如果没有找到满足条件的路由，调用NotFoundHandler的ServeHTTP。<br>以上就是http包的大致工作流程。为便于读者清晰理解，这里把核心源码按照功能整理如下。<br>(1)路由注册对应的源码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http<span class="token punctuation">.</span>HandlerFunc<span class="token punctuation">:</span>
<span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>
<span class="token keyword">func</span><span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> ServeHTTP <span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span>
<span class="token keyword">func</span> HandleFunc <span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">func</span>
<span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span>accern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> http<span class="token punctuation">.</span>Handle<span class="token punctuation">:</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)接口监听相关源码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span><span class="token builtin">error</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(3)接收客户端请求<br>Server的Serve方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Serve</span><span class="token punctuation">(</span><span class="token number">1</span> net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Server的newConn方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">newConn</span><span class="token punctuation">(</span>rwc net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span>conn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(4)分配Handler</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
fune <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span>serve <span class="token punctuation">(</span><span class="token punctuation">)</span>
c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">readRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>w <span class="token operator">*</span>response<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span>
<span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req Request<span class="token punctuation">)</span>
DefaultServeMux
<span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span>
<span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span>
Handler接口的定义：
<span class="token keyword">type</span> Handler <span class="token keyword">interface</span>
ServeMux<span class="token punctuation">.</span>ServeHTTP
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span><span class="token function">ServelITTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span>
mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span><span class="token function">Handler</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> handler <span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言的http有两个核心功能：Conn和ServeMux。</p><h3 id="Conn的goroutine"><a class="header-anchor" href="#Conn的goroutine">¶</a>Conn的goroutine</h3><p>Go 语言为了实现高并发和高性能, 使用goroutines处理Conn的读写事件，这样每个请求都能保持独立，相互不会阻塞，以高效响应网络事件。</p><p>Go语言在等待客户端请求时写下如下代码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">
c<span class="token punctuation">,</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span>
        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端的每次请求都会创建一个Conn，这个Conn里面保存了该次请求的信息，然后再传递到对应的handler，该handler中便可以读取到相应的header信息，以保证了每个请求的独立性。</p><h3 id="ServeMux的自定义"><a class="header-anchor" href="#ServeMux的自定义">¶</a>ServeMux的自定义</h3><p>conn.server内部调用了http包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            mu sync<span class="token punctuation">.</span>RWMutex   <span class="token comment">//锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span>
            m  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry  <span class="token comment">// 路由规则，一个 string 对应一个 mux 实体，这里的string就是注册的路由表达式</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>muxEntry结构体定义。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> muxEntry <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            explicit <span class="token builtin">bool</span>   <span class="token comment">// 是否精确匹配</span>
            h       Handler <span class="token comment">// 这个路由表达式对应哪个handler</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Handler的定义，Handler是接收请求后逻辑处理和生成返回信息的逻辑。。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>
            <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>  <span class="token comment">// 路由实现器</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>调用了 HandlerFunc(f)，类似强制类型转换 f 成为HandlerFunc类型，这样f就拥有了ServHTTP方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>
        <span class="token comment">// ServeHTTP calls f(w, r).</span>
        <span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>路由器接收到请求之后调用mux.handler®.ServeHTTP(w, r)，也就是调用对应路由的handler的ServerHTTP接口，那么mux.handler®怎么处理的呢？根据用户请求的URL和路由器里面存储的map去匹配的，当匹配到之后返回存储的handler，调用这个handler的ServHTTP接口就可以执行到相应的函数了。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> Handler <span class="token punctuation">{</span>
            mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// Host-specific pattern takes precedence over generic ones</span>
            h <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Host <span class="token operator">+</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
            <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                h <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                h <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> h
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 语言其实支持外部实现的路由器 ListenAndServe的第二个参数就是用以配置外部路由器的，它是一个Handler接口，即外部路由器只要实现了 Handler 接口就可以，我们可以在自己实现的路由器的ServHTTP里面实现自定义路由功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">
<span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
            <span class="token string">"fmt"</span>
            <span class="token string">"net/http"</span>
        <span class="token punctuation">)</span>
        <span class="token keyword">type</span> MyMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>MyMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path <span class="token operator">==</span> <span class="token string">"/"</span> <span class="token punctuation">{</span>
                <span class="token function">sayhelloName</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            <span class="token punctuation">}</span>
            http<span class="token punctuation">.</span><span class="token function">NotFound</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">func</span> <span class="token function">sayhelloName</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello myroute!"</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mux <span class="token operator">:=</span> <span class="token operator">&amp;</span>MyMux<span class="token punctuation">{</span><span class="token punctuation">}</span>
            http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":9090"</span><span class="token punctuation">,</span> mux<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言代码的执行流程<br>通过对http包的分析之后，现在让我们来梳理一下整个的代码执行过程。<br>1.首先调用Http.HandleFunc，按顺序做如下操作。<br>● 调用了DefaultServerMux的HandleFunc。<br>● 调用了DefaultServerMux的Handle。<br>● 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则。<br>2.其次调用http.ListenAndServe(“:9090”, nil)，按顺序做如下操作。<br>● 实例化Server。<br>● 调用Server的ListenAndServe()。<br>● 调用net.Listen(“tcp”, addr)监听端口。<br>● 启动一个for循环，在循环体中Accept请求。<br>● 对每个请求实例化一个 Conn，并且开启一个 goroutine 为这个请求进行服务 go c.serve()。<br>● 读取每个请求的内容w, err := c.readRequest()。<br>● 判断handler是否为空，如果没有设置handler（这个例子就没有设置handler）， handler就设置为DefaultServeMux。<br>● 调用handler的ServeHttp。<br>● 在这个例子中，下面就进入到DefaultServerMux.ServeHttp。<br>● 根据request选择handler，并且进入到这个handler的ServeHTTP，<br><code>mux.handler(r).ServeHTTP(w, r)</code><br>● 选择handler：<br>a.判断是否有路由能满足这个request（循环遍历ServerMux的muxEntry）。<br>b.如果有路由满足，调用这个路由handler的ServeHttp。<br>c.如果没有路由满足，调用NotFoundHandler的ServeHttp。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Xiong Hao</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="http://bearhao.github.io/posts/54137.html">http://bearhao.github.io/posts/54137.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Xiong Hao</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Go/"><span class="chip bg-color">Go</span> </a><a href="/tags/Web/"><span class="chip bg-color">Web</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/medias/loading.gif" data-original="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/medias/loading.gif" data-original="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(/medias/logo.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"CziybjXAzXS8K5QoM2OYJlDa-gzGzoHsz",appKey:"rCE0R5EutB05YPUVwT0d5A9f",serverURLs:"",notify:!0,verify:!0,visitor:!0,avatar:"monsterid",pageSize:"9",lang:"zh-cn",placeholder:"Welcome to talk!"})</script><div id="to_comment" class="comment-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#vcomments" title="直达评论"><i class="fas fa-comments"></i></a></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/62652.html"><div class="card-image"><img src="/medias/loading.gif" data-original="https://media6x.files.wordpress.com/2023/01/2.jpg" class="responsive-img" alt="关于的 MarkDown 使用"> <span class="card-title">关于的 MarkDown 使用</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2021-09-07 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/MarkDown/" class="post-category">MarkDown</a></span></div></div><div class="card-action article-tags"><a href="/tags/MarkDown/"><span class="chip bg-color">MarkDown</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">本篇&nbsp;<i class="far fa-dot-circle"></i></div><div class="card"><a href="/posts/54137.html"><div class="card-image"><img src="/medias/loading.gif" data-original="https://media6x.files.wordpress.com/2023/01/2.jpg" class="responsive-img" alt="Go Web 编程原理"> <span class="card-title">Go Web 编程原理</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2021-09-07 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Golang/" class="post-category">Golang</a></span></div></div><div class="card-action article-tags"><a href="/tags/Go/"><span class="chip bg-color">Go</span> </a><a href="/tags/Web/"><span class="chip bg-color">Web</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){var n,t,o,i;void 0!==window.getSelection&&((""+(n=window.getSelection())).length<Number.parseInt("1200")||(t=document.getElementsByTagName("body")[0],(o=document.createElement("div")).style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>"),i=document.location.href,o.innerHTML+='<br />来源: 韜の道<br />文章作者: Xiong Hao<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)))})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/prism/prism.min.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5, h6'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><link rel="stylesheet" href="/libs/aplayer/APlayer.min.css"><style>.aplayer .aplayer-lrc p{display:none;font-size:12px;font-weight:700;line-height:16px!important}.aplayer .aplayer-lrc p.aplayer-lrc-current{display:none;font-size:15px;color:#42b983}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><div><div class="row"><meting-js class="col l8 offset-l2 m10 offset-m1 s12" server="netease" type="playlist" id="503838841" fixed="true" autoplay theme="#42b983" loop order="random" preload="auto" volume="0.7" list-folded="true"></meting-js></div></div><script src="/libs/aplayer/APlayer.min.js"></script><script src="/libs/aplayer/Meting.min.js"></script><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2021-2023</span> <a href="/about" target="_blank">Xiong Hao</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">17.3k</span> <span id="busuanzi_container_site_pv">&nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp; <span id="busuanzi_value_site_pv" class="white-color"></span> </span><span id="busuanzi_container_site_uv">&nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp; <span id="busuanzi_value_site_uv" class="white-color"></span></span><br><span id="sitetime">Loading ...</span><script>var calcSiteTime=function(){var e,t,n=new Date,i="2021",a=n.getFullYear(),r=n.getMonth()+1,o=n.getDate(),s=n.getHours(),g=n.getMinutes(),d=n.getSeconds(),m=Date.UTC(i,"7","15","0","0","0"),c=Date.UTC(a,r,o,s,g,d)-m,l=Math.floor(c/31536e6),u=Math.floor(c/864e5-365*l);i===String(a)?(document.getElementById("year").innerHTML=a,e="This site has been running for "+u+" days",e="本站已运行 "+u+" 天",document.getElementById("sitetime").innerHTML=e):(document.getElementById("year").innerHTML=i+" - "+a,t="This site has been running for "+l+" years and "+u+" days",t="本站已运行 "+l+" 年 "+u+" 天",document.getElementById("sitetime").innerHTML=t)};calcSiteTime()</script><br><span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom"> <a href="/null" target="_blank"></a></span></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/bearhao" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:2733443175@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2733443175" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2733443175" data-position="top" data-delay="50"><i class="fab fa-qq"></i> </a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script type="text/javascript">$(function(){!function(t,s,i){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),n=document.getElementById(s),r=document.getElementById(i);n.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var n,e,r,s,i,l=!0,a=t.title.trim().toLowerCase(),c=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),u=0===(u=t.url).indexOf("/")?t.url:"/"+u,o=-1,h=-1;""!==a&&""!==c&&m.forEach(function(t,e){n=a.indexOf(t),o=c.indexOf(t),n<0&&o<0?l=!1:(o<0&&(o=0),0===e&&(h=o))}),l&&(f+="<li><a href='"+u+"' class='search-result-title'>"+a+"</a>",e=t.content.trim().replace(/<[^>]+>/g,""),0<=h&&(s=h+80,(r=h-20)<0&&(r=0),0===r&&(s=100),s>e.length&&(s=e.length),i=e.substr(r,s),m.forEach(function(t){var e=new RegExp(t,"gi");i=i.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+i+"...</p>"),f+="</li>")}),f+="</ul>",r.innerHTML=f)})}})}("/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script src="/libs/mermaid/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script><script type="text/javascript">var windowWidth=$(window).width();768<windowWidth&&document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>')</script><script src="https://ssl.captcha.qq.com/TCaptcha.js"></script><script src="/libs/others/TencentCaptcha.js"></script><button id="TencentCaptcha" data-appid="CziybjXAzXS8K5QoM2OYJlDa-gzGzoHsz" data-cbfn="callback" type="button" hidden></button><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/libs/others/clicklove.js" async></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async></script><script src="/libs/instantpage/instantpage.js" type="module"></script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(a){a.imageLazyLoadSetting.processImages=t;var e=a.imageLazyLoadSetting.isSPA,i=a.imageLazyLoadSetting.preloadRatio||1,o=r();function r(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(o=r());for(var t,n=0;n<o.length;n++)0<=(t=o[n].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(a.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var e=o[n];!function(t,e){if(t.hasAttribute("bg-lazy"))return t.removeAttribute("bg-lazy"),e();var n=new Image,a=t.getAttribute("data-original");n.onload=function(){t.src=a,t.removeAttribute("data-original"),e()},t.src!==a&&(n.src=a)}(e,function(){o=o.filter(function(t){return e!==t}),a.imageLazyLoadSetting.onImageLoaded&&a.imageLazyLoadSetting.onImageLoaded(e)})}()}function n(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",n),a.addEventListener("resize",n),a.addEventListener("orientationchange",n)}(this)</script></body></html>